//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro
//_\source tt_um_warpv.tlv 37
//_\SV
   // Include WARP-V.

   // Included URL: "https://raw.githubusercontent.com/stevehoover/warp-v/2bd28077b7526d460f4615e687ab71e074a35f5a/warp-v.tlv"// Included URL: "https://raw.githubusercontent.com/stevehoover/tlv_lib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentals_lib.tlv"// Included URL: "https://raw.githubusercontent.com/stevehoover/warp-v_includes/74e617bacf0a0421b748cfe0d71072b4192f743c/risc-v_defs.tlv"
   /* verilator lint_off WIDTH */
   /* verilator lint_off PINMISSING */
   /* verilator lint_off SELRANGE */

`default_nettype none

module tt_um_warpv (
    input  wire [7:0] ui_in,    // Dedicated inputs - connected to the input switches
    output wire [7:0] uo_out,   // Dedicated outputs - connected to the 7 segment display
    input  wire [7:0] uio_in,   // IOs: Bidirectional Input path
    output wire [7:0] uio_out,  // IOs: Bidirectional Output path
    output wire [7:0] uio_oe,   // IOs: Bidirectional Enable path (active high: 0=input, 1=output)
    input  wire       ena,      // will go high when the design is enabled
    input  wire       clk,      // clock
    input  wire       rst_n     // reset_n - low to reset
);

   wire reset = ! rst_n;
   wire passed, failed;
   wire [31:0] cyc_cnt = 32'd0;  // Used by test bench (default WARP-V Makerchip test bench). Don't actually count. Never fail due to timeout by this mechanism.
// ---------- Generated Code Inlined Here (before 1st \TLV) ----------
// Generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro from Redwood EDA, LLC.
// Redwood EDA, LLC does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


// For silencing unused signal messages.
`define BOGUS_USE(ignore)


genvar bank, instr_mem, mem, pipe_ctrl_instr, pipe_ctrl_stage, regs, src;


//
// Signals declared top-level.
//

// For |fetch$Cnt.
logic [7:0] FETCH_Cnt_n2,
            FETCH_Cnt_n1;

// For |fetch$fetch.
logic FETCH_fetch_a0;

// For |fetch$fetch_word.
logic [31:0] FETCH_fetch_word_a0;

// For |fetch$reset.
logic FETCH_reset_n1,
      FETCH_reset_a0;

// For |fetch$soft_reset.
logic FETCH_soft_reset_n1;

// For |fetch/instr$GoodPathMask.
logic [1+1:0] FETCH_Instr_GoodPathMask_n1,
              FETCH_Instr_GoodPathMask_a0;

// For |fetch/instr$Pc.
logic [31:0] FETCH_Instr_Pc_n1,
             FETCH_Instr_Pc_a0;

// For |fetch/instr$RemainingCyclesWithinTimeUnit.
logic [30-1:0] FETCH_Instr_RemainingCyclesWithinTimeUnit_n1,
               FETCH_Instr_RemainingCyclesWithinTimeUnit_a0;

// For |fetch/instr$abort.
logic FETCH_Instr_abort_a0;

// For |fetch/instr$aborting_isa_trap.
logic FETCH_Instr_aborting_isa_trap_a0;

// For |fetch/instr$aborting_trap.
logic FETCH_Instr_aborting_trap_a0,
      FETCH_Instr_aborting_trap_a1;

// For |fetch/instr$aborting_trap_cond.
logic FETCH_Instr_aborting_trap_cond_a0;

// For |fetch/instr$add_rslt.
logic [31:0] FETCH_Instr_add_rslt_a0;

// For |fetch/instr$add_sub_rslt.
logic [31:0] FETCH_Instr_add_sub_rslt_a0;

// For |fetch/instr$addi_rslt.
logic [31:0] FETCH_Instr_addi_rslt_a0;

// For |fetch/instr$addr.
logic [31:0] FETCH_Instr_addr_a0;
logic [1:0] FETCH_Instr_addr_a1;

// For |fetch/instr$and_rslt.
logic [31:0] FETCH_Instr_and_rslt_a0;

// For |fetch/instr$andi_rslt.
logic [31:0] FETCH_Instr_andi_rslt_a0;

// For |fetch/instr$auipc_rslt.
logic [31:0] FETCH_Instr_auipc_rslt_a0;

// For |fetch/instr$branch.
logic FETCH_Instr_branch_a0;

// For |fetch/instr$branch_redir_pc.
logic [31:0] FETCH_Instr_branch_redir_pc_a0;

// For |fetch/instr$branch_target.
logic [31:0] FETCH_Instr_branch_target_a0;

// For |fetch/instr$commit.
logic FETCH_Instr_commit_a0;

// For |fetch/instr$commit_dest_reg.
logic FETCH_Instr_commit_dest_reg_a0;

// For |fetch/instr$commit_second_issue.
logic FETCH_Instr_commit_second_issue_a0;

// For |fetch/instr$conditional_branch.
logic FETCH_Instr_conditional_branch_a0;

// For |fetch/instr$csr_cycle.
logic [31:0] FETCH_Instr_csr_cycle_n1,
             FETCH_Instr_csr_cycle_a0;

// For |fetch/instr$csr_cycle_hw_wr.
logic FETCH_Instr_csr_cycle_hw_wr_a0;

// For |fetch/instr$csr_cycle_hw_wr_en_mask.
logic [31:0] FETCH_Instr_csr_cycle_hw_wr_en_mask_a0;

// For |fetch/instr$csr_cycle_hw_wr_mask.
logic [31:0] FETCH_Instr_csr_cycle_hw_wr_mask_a0;

// For |fetch/instr$csr_cycle_hw_wr_value.
logic [31:0] FETCH_Instr_csr_cycle_hw_wr_value_a0;

// For |fetch/instr$csr_cycle_masked_wr_value.
logic [31:0] FETCH_Instr_csr_cycle_masked_wr_value_a0;

// For |fetch/instr$csr_cycleh.
logic [31:0] FETCH_Instr_csr_cycleh_n1,
             FETCH_Instr_csr_cycleh_a0;

// For |fetch/instr$csr_cycleh_hw_wr.
logic FETCH_Instr_csr_cycleh_hw_wr_a0;

// For |fetch/instr$csr_cycleh_hw_wr_en_mask.
logic [31:0] FETCH_Instr_csr_cycleh_hw_wr_en_mask_a0;

// For |fetch/instr$csr_cycleh_hw_wr_mask.
logic [31:0] FETCH_Instr_csr_cycleh_hw_wr_mask_a0;

// For |fetch/instr$csr_cycleh_hw_wr_value.
logic [31:0] FETCH_Instr_csr_cycleh_hw_wr_value_a0;

// For |fetch/instr$csr_cycleh_masked_wr_value.
logic [31:0] FETCH_Instr_csr_cycleh_masked_wr_value_a0;

// For |fetch/instr$csr_instret.
logic [31:0] FETCH_Instr_csr_instret_n1,
             FETCH_Instr_csr_instret_a0;

// For |fetch/instr$csr_instret_hw_wr.
logic FETCH_Instr_csr_instret_hw_wr_a0;

// For |fetch/instr$csr_instret_hw_wr_en_mask.
logic [31:0] FETCH_Instr_csr_instret_hw_wr_en_mask_a0;

// For |fetch/instr$csr_instret_hw_wr_mask.
logic [31:0] FETCH_Instr_csr_instret_hw_wr_mask_a0;

// For |fetch/instr$csr_instret_hw_wr_value.
logic [31:0] FETCH_Instr_csr_instret_hw_wr_value_a0;

// For |fetch/instr$csr_instret_masked_wr_value.
logic [31:0] FETCH_Instr_csr_instret_masked_wr_value_a0;

// For |fetch/instr$csr_instreth.
logic [31:0] FETCH_Instr_csr_instreth_n1,
             FETCH_Instr_csr_instreth_a0;

// For |fetch/instr$csr_instreth_hw_wr.
logic FETCH_Instr_csr_instreth_hw_wr_a0;

// For |fetch/instr$csr_instreth_hw_wr_en_mask.
logic [31:0] FETCH_Instr_csr_instreth_hw_wr_en_mask_a0;

// For |fetch/instr$csr_instreth_hw_wr_mask.
logic [31:0] FETCH_Instr_csr_instreth_hw_wr_mask_a0;

// For |fetch/instr$csr_instreth_hw_wr_value.
logic [31:0] FETCH_Instr_csr_instreth_hw_wr_value_a0;

// For |fetch/instr$csr_instreth_masked_wr_value.
logic [31:0] FETCH_Instr_csr_instreth_masked_wr_value_a0;

// For |fetch/instr$csr_time.
logic [31:0] FETCH_Instr_csr_time_n1,
             FETCH_Instr_csr_time_a0;

// For |fetch/instr$csr_time_hw_wr.
logic FETCH_Instr_csr_time_hw_wr_a0;

// For |fetch/instr$csr_time_hw_wr_en_mask.
logic [31:0] FETCH_Instr_csr_time_hw_wr_en_mask_a0;

// For |fetch/instr$csr_time_hw_wr_mask.
logic [31:0] FETCH_Instr_csr_time_hw_wr_mask_a0;

// For |fetch/instr$csr_time_hw_wr_value.
logic [31:0] FETCH_Instr_csr_time_hw_wr_value_a0;

// For |fetch/instr$csr_time_masked_wr_value.
logic [31:0] FETCH_Instr_csr_time_masked_wr_value_a0;

// For |fetch/instr$csr_timeh.
logic [31:0] FETCH_Instr_csr_timeh_n1,
             FETCH_Instr_csr_timeh_a0;

// For |fetch/instr$csr_timeh_hw_wr.
logic FETCH_Instr_csr_timeh_hw_wr_a0;

// For |fetch/instr$csr_timeh_hw_wr_en_mask.
logic [31:0] FETCH_Instr_csr_timeh_hw_wr_en_mask_a0;

// For |fetch/instr$csr_timeh_hw_wr_mask.
logic [31:0] FETCH_Instr_csr_timeh_hw_wr_mask_a0;

// For |fetch/instr$csr_timeh_hw_wr_value.
logic [31:0] FETCH_Instr_csr_timeh_hw_wr_value_a0;

// For |fetch/instr$csr_timeh_masked_wr_value.
logic [31:0] FETCH_Instr_csr_timeh_masked_wr_value_a0;

// For |fetch/instr$csr_trap.
logic FETCH_Instr_csr_trap_a0;

// For |fetch/instr$csr_wr_value.
logic [31:0] FETCH_Instr_csr_wr_value_a0;

// For |fetch/instr$csrrc_rslt.
logic [31:0] FETCH_Instr_csrrc_rslt_a0;

// For |fetch/instr$csrrci_rslt.
logic [31:0] FETCH_Instr_csrrci_rslt_a0;

// For |fetch/instr$csrrs_rslt.
logic [31:0] FETCH_Instr_csrrs_rslt_a0;

// For |fetch/instr$csrrsi_rslt.
logic [31:0] FETCH_Instr_csrrsi_rslt_a0;

// For |fetch/instr$csrrw_rslt.
logic [31:0] FETCH_Instr_csrrw_rslt_a0;

// For |fetch/instr$csrrwi_rslt.
logic [31:0] FETCH_Instr_csrrwi_rslt_a0;

// For |fetch/instr$dest_pending.
logic FETCH_Instr_dest_pending_a0;

// For |fetch/instr$dest_reg.
logic [4:0] FETCH_Instr_dest_reg_a0,
            FETCH_Instr_dest_reg_a1;

// For |fetch/instr$dest_reg_valid.
logic FETCH_Instr_dest_reg_valid_a0;

// For |fetch/instr$div_mul.
logic FETCH_Instr_div_mul_a0;

// For |fetch/instr$equal.
logic FETCH_Instr_equal_a0;

// For |fetch/instr$failed.
logic FETCH_Instr_failed_a0;

// For |fetch/instr$fetch.
logic FETCH_Instr_fetch_a0;

// For |fetch/instr$first_issue.
logic FETCH_Instr_first_issue_a0;

// For |fetch/instr$full_csr_cycle_hw_wr_value.
logic [63:0] FETCH_Instr_full_csr_cycle_hw_wr_value_a0;

// For |fetch/instr$full_csr_instret_hw_wr_value.
logic [63:0] FETCH_Instr_full_csr_instret_hw_wr_value_a0;

// For |fetch/instr$full_csr_time_hw_wr_value.
logic [63:0] FETCH_Instr_full_csr_time_hw_wr_value_a0;

// For |fetch/instr$good_path.
logic FETCH_Instr_good_path_a0;

// For |fetch/instr$illegal.
logic FETCH_Instr_illegal_a0;

// For |fetch/instr$illegal_itype_with_funct7.
logic FETCH_Instr_illegal_itype_with_funct7_a0;

// For |fetch/instr$imm_valid.
logic FETCH_Instr_imm_valid_a0;

// For |fetch/instr$imm_value.
logic [31:0] FETCH_Instr_imm_value_a0;

// For |fetch/instr$indirect_jump.
logic FETCH_Instr_indirect_jump_a0;

// For |fetch/instr$indirect_jump_cond.
logic FETCH_Instr_indirect_jump_cond_a0;

// For |fetch/instr$indirect_jump_full_target.
logic [31:0] FETCH_Instr_indirect_jump_full_target_a0;

// For |fetch/instr$indirect_jump_target.
logic [31:0] FETCH_Instr_indirect_jump_target_a0;

// For |fetch/instr$is___type.
logic FETCH_Instr_is___type_a0;

// For |fetch/instr$is_add_instr.
logic FETCH_Instr_is_add_instr_a0;

// For |fetch/instr$is_addi_instr.
logic FETCH_Instr_is_addi_instr_a0;

// For |fetch/instr$is_and_instr.
logic FETCH_Instr_is_and_instr_a0;

// For |fetch/instr$is_andi_instr.
logic FETCH_Instr_is_andi_instr_a0;

// For |fetch/instr$is_auipc_instr.
logic FETCH_Instr_is_auipc_instr_a0;

// For |fetch/instr$is_b_type.
logic FETCH_Instr_is_b_type_a0;

// For |fetch/instr$is_beq_instr.
logic FETCH_Instr_is_beq_instr_a0;

// For |fetch/instr$is_bge_instr.
logic FETCH_Instr_is_bge_instr_a0;

// For |fetch/instr$is_bgeu_instr.
logic FETCH_Instr_is_bgeu_instr_a0;

// For |fetch/instr$is_blt_instr.
logic FETCH_Instr_is_blt_instr_a0;

// For |fetch/instr$is_bltu_instr.
logic FETCH_Instr_is_bltu_instr_a0;

// For |fetch/instr$is_bne_instr.
logic FETCH_Instr_is_bne_instr_a0;

// For |fetch/instr$is_csr_clear.
logic FETCH_Instr_is_csr_clear_a0;

// For |fetch/instr$is_csr_cycle.
logic FETCH_Instr_is_csr_cycle_a0;

// For |fetch/instr$is_csr_cycleh.
logic FETCH_Instr_is_csr_cycleh_a0;

// For |fetch/instr$is_csr_instr.
logic FETCH_Instr_is_csr_instr_a0;

// For |fetch/instr$is_csr_instret.
logic FETCH_Instr_is_csr_instret_a0;

// For |fetch/instr$is_csr_instreth.
logic FETCH_Instr_is_csr_instreth_a0;

// For |fetch/instr$is_csr_set.
logic FETCH_Instr_is_csr_set_a0;

// For |fetch/instr$is_csr_time.
logic FETCH_Instr_is_csr_time_a0;

// For |fetch/instr$is_csr_timeh.
logic FETCH_Instr_is_csr_timeh_a0;

// For |fetch/instr$is_csr_write.
logic FETCH_Instr_is_csr_write_a0;

// For |fetch/instr$is_csrrc_instr.
logic FETCH_Instr_is_csrrc_instr_a0;

// For |fetch/instr$is_csrrci_instr.
logic FETCH_Instr_is_csrrci_instr_a0;

// For |fetch/instr$is_csrrs_instr.
logic FETCH_Instr_is_csrrs_instr_a0;

// For |fetch/instr$is_csrrsi_instr.
logic FETCH_Instr_is_csrrsi_instr_a0;

// For |fetch/instr$is_csrrw_instr.
logic FETCH_Instr_is_csrrw_instr_a0;

// For |fetch/instr$is_csrrwi_instr.
logic FETCH_Instr_is_csrrwi_instr_a0;

// For |fetch/instr$is_dest_condition.
logic FETCH_Instr_is_dest_condition_a0;

// For |fetch/instr$is_i_type.
logic FETCH_Instr_is_i_type_a0;

// For |fetch/instr$is_j_type.
logic FETCH_Instr_is_j_type_a0;

// For |fetch/instr$is_jal_instr.
logic FETCH_Instr_is_jal_instr_a0;

// For |fetch/instr$is_jalr_instr.
logic FETCH_Instr_is_jalr_instr_a0;

// For |fetch/instr$is_lb_instr.
logic FETCH_Instr_is_lb_instr_a0;

// For |fetch/instr$is_lbu_instr.
logic FETCH_Instr_is_lbu_instr_a0;

// For |fetch/instr$is_lh_instr.
logic FETCH_Instr_is_lh_instr_a0;

// For |fetch/instr$is_lhu_instr.
logic FETCH_Instr_is_lhu_instr_a0;

// For |fetch/instr$is_lui_instr.
logic FETCH_Instr_is_lui_instr_a0;

// For |fetch/instr$is_lw_instr.
logic FETCH_Instr_is_lw_instr_a0;

// For |fetch/instr$is_or_instr.
logic FETCH_Instr_is_or_instr_a0;

// For |fetch/instr$is_ori_instr.
logic FETCH_Instr_is_ori_instr_a0;

// For |fetch/instr$is_r2_type.
logic FETCH_Instr_is_r2_type_a0;

// For |fetch/instr$is_r4_type.
logic FETCH_Instr_is_r4_type_a0;

// For |fetch/instr$is_r_type.
logic FETCH_Instr_is_r_type_a0;

// For |fetch/instr$is_s_type.
logic FETCH_Instr_is_s_type_a0;

// For |fetch/instr$is_sb_instr.
logic FETCH_Instr_is_sb_instr_a0;

// For |fetch/instr$is_sh_instr.
logic FETCH_Instr_is_sh_instr_a0;

// For |fetch/instr$is_sll_instr.
logic FETCH_Instr_is_sll_instr_a0;

// For |fetch/instr$is_slli_instr.
logic FETCH_Instr_is_slli_instr_a0;

// For |fetch/instr$is_slt_instr.
logic FETCH_Instr_is_slt_instr_a0;

// For |fetch/instr$is_slti_instr.
logic FETCH_Instr_is_slti_instr_a0;

// For |fetch/instr$is_sltiu_instr.
logic FETCH_Instr_is_sltiu_instr_a0;

// For |fetch/instr$is_sltu_instr.
logic FETCH_Instr_is_sltu_instr_a0;

// For |fetch/instr$is_sra_instr.
logic FETCH_Instr_is_sra_instr_a0;

// For |fetch/instr$is_srai_instr.
logic FETCH_Instr_is_srai_instr_a0;

// For |fetch/instr$is_srl_instr.
logic FETCH_Instr_is_srl_instr_a0;

// For |fetch/instr$is_srli_instr.
logic FETCH_Instr_is_srli_instr_a0;

// For |fetch/instr$is_srli_srai_instr.
logic FETCH_Instr_is_srli_srai_instr_a0;

// For |fetch/instr$is_sub_instr.
logic FETCH_Instr_is_sub_instr_a0;

// For |fetch/instr$is_sw_instr.
logic FETCH_Instr_is_sw_instr_a0;

// For |fetch/instr$is_u_type.
logic FETCH_Instr_is_u_type_a0;

// For |fetch/instr$is_xor_instr.
logic FETCH_Instr_is_xor_instr_a0;

// For |fetch/instr$is_xori_instr.
logic FETCH_Instr_is_xori_instr_a0;

// For |fetch/instr$jal_rslt.
logic [31:0] FETCH_Instr_jal_rslt_a0;

// For |fetch/instr$jalr_rslt.
logic [31:0] FETCH_Instr_jalr_rslt_a0;

// For |fetch/instr$jump.
logic FETCH_Instr_jump_a0;

// For |fetch/instr$jump_cond.
logic FETCH_Instr_jump_cond_a0;

// For |fetch/instr$jump_target.
logic [31:0] FETCH_Instr_jump_target_a0;

// For |fetch/instr$lb_rslt.
logic [31:0] FETCH_Instr_lb_rslt_a0;

// For |fetch/instr$lbu_rslt.
logic [31:0] FETCH_Instr_lbu_rslt_a0;

// For |fetch/instr$ld.
logic FETCH_Instr_ld_a0;

// For |fetch/instr$ld_data.
logic [31:0] FETCH_Instr_ld_data_a0,
             FETCH_Instr_ld_data_a1;

// For |fetch/instr$ld_st.
logic FETCH_Instr_ld_st_a0;

// For |fetch/instr$ld_st_cond.
logic FETCH_Instr_ld_st_cond_a0;

// For |fetch/instr$ld_st_half.
logic FETCH_Instr_ld_st_half_a0,
      FETCH_Instr_ld_st_half_a1;

// For |fetch/instr$ld_st_word.
logic FETCH_Instr_ld_st_word_a0,
      FETCH_Instr_ld_st_word_a1;

// For |fetch/instr$lh_rslt.
logic [31:0] FETCH_Instr_lh_rslt_a0;

// For |fetch/instr$lhu_rslt.
logic [31:0] FETCH_Instr_lhu_rslt_a0;

// For |fetch/instr$lui_rslt.
logic [31:0] FETCH_Instr_lui_rslt_a0;

// For |fetch/instr$lw_rslt.
logic [31:0] FETCH_Instr_lw_rslt_a0;

// For |fetch/instr$misaligned_indirect_jump_target.
logic FETCH_Instr_misaligned_indirect_jump_target_a0;

// For |fetch/instr$misaligned_jump_target.
logic FETCH_Instr_misaligned_jump_target_a0;

// For |fetch/instr$misaligned_pc.
logic FETCH_Instr_misaligned_pc_a0;

// For |fetch/instr$mispred_branch.
logic FETCH_Instr_mispred_branch_a0;

// For |fetch/instr$mispred_branch_cond.
logic FETCH_Instr_mispred_branch_cond_a0;

// For |fetch/instr$mnemonic.
logic [10*8-1:0] FETCH_Instr_mnemonic_a0;

// For |fetch/instr$next_good_path_mask.
logic [1+1:0] FETCH_Instr_next_good_path_mask_a0;

// For |fetch/instr$next_no_fetch.
logic FETCH_Instr_next_no_fetch_a0;

// For |fetch/instr$next_pc.
logic [31:0] FETCH_Instr_next_pc_a0;

// For |fetch/instr$no_fetch.
logic FETCH_Instr_no_fetch_a0,
      FETCH_Instr_no_fetch_a1;

// For |fetch/instr$no_fetch_cond.
logic FETCH_Instr_no_fetch_cond_a0;

// For |fetch/instr$non_aborting_isa_trap.
logic FETCH_Instr_non_aborting_isa_trap_a0;

// For |fetch/instr$non_aborting_trap.
logic FETCH_Instr_non_aborting_trap_a0,
      FETCH_Instr_non_aborting_trap_a1;

// For |fetch/instr$non_aborting_trap_cond.
logic FETCH_Instr_non_aborting_trap_cond_a0;

// For |fetch/instr$non_pipelined.
logic FETCH_Instr_non_pipelined_a0,
      FETCH_Instr_non_pipelined_a1;

// For |fetch/instr$non_pipelined_cond.
logic FETCH_Instr_non_pipelined_cond_a0;

// For |fetch/instr$or_rslt.
logic [31:0] FETCH_Instr_or_rslt_a0;

// For |fetch/instr$ori_rslt.
logic [31:0] FETCH_Instr_ori_rslt_a0;

// For |fetch/instr$passed.
logic FETCH_Instr_passed_a0;

// For |fetch/instr$pc.
logic [31:0] FETCH_Instr_pc_a0,
             FETCH_Instr_pc_a1;

// For |fetch/instr$pc_inc.
logic [31:0] FETCH_Instr_pc_inc_a0,
             FETCH_Instr_pc_inc_a1;

// For |fetch/instr$pending_replay.
logic FETCH_Instr_pending_replay_a0;

// For |fetch/instr$pred_taken.
logic FETCH_Instr_pred_taken_a0;

// For |fetch/instr$raw.
logic [31:0] FETCH_Instr_raw_a0;

// For |fetch/instr$raw_aq.
logic FETCH_Instr_raw_aq_a0;

// For |fetch/instr$raw_b_imm.
logic [31:0] FETCH_Instr_raw_b_imm_a0;

// For |fetch/instr$raw_funct3.
logic [2:0] FETCH_Instr_raw_funct3_a0;
logic [2:2] FETCH_Instr_raw_funct3_a1;

// For |fetch/instr$raw_funct7.
logic [6:0] FETCH_Instr_raw_funct7_a0;

// For |fetch/instr$raw_i_imm.
logic [31:0] FETCH_Instr_raw_i_imm_a0;

// For |fetch/instr$raw_j_imm.
logic [31:0] FETCH_Instr_raw_j_imm_a0;

// For |fetch/instr$raw_op2.
logic [1:0] FETCH_Instr_raw_op2_a0;

// For |fetch/instr$raw_op5.
logic [4:0] FETCH_Instr_raw_op5_a0;

// For |fetch/instr$raw_rd.
logic [4:0] FETCH_Instr_raw_rd_a0;

// For |fetch/instr$raw_rl.
logic FETCH_Instr_raw_rl_a0;

// For |fetch/instr$raw_rm.
logic [2:0] FETCH_Instr_raw_rm_a0;

// For |fetch/instr$raw_rs1.
logic [4:0] FETCH_Instr_raw_rs1_a0;

// For |fetch/instr$raw_rs2.
logic [4:0] FETCH_Instr_raw_rs2_a0;

// For |fetch/instr$raw_rs3.
logic [4:0] FETCH_Instr_raw_rs3_a0;

// For |fetch/instr$raw_s_imm.
logic [31:0] FETCH_Instr_raw_s_imm_a0;

// For |fetch/instr$raw_shamt.
logic [6:0] FETCH_Instr_raw_shamt_a0;

// For |fetch/instr$raw_u_imm.
logic [31:0] FETCH_Instr_raw_u_imm_a0;

// For |fetch/instr$reg_wr_pending.
logic FETCH_Instr_reg_wr_pending_a0;

// For |fetch/instr$replay.
logic FETCH_Instr_replay_a0,
      FETCH_Instr_replay_a1;

// For |fetch/instr$replay_cond.
logic FETCH_Instr_replay_cond_a0;

// For |fetch/instr$replay_trap.
logic FETCH_Instr_replay_trap_a0;

// For |fetch/instr$reset.
logic FETCH_Instr_reset_n1,
      FETCH_Instr_reset_a0;

// For |fetch/instr$rslt.
logic [31:0] FETCH_Instr_rslt_a0;

// For |fetch/instr$second_issue.
logic FETCH_Instr_second_issue_a0,
      FETCH_Instr_second_issue_a1;

// For |fetch/instr$second_issue_cond.
logic FETCH_Instr_second_issue_cond_a0;

// For |fetch/instr$second_issue_ld.
logic FETCH_Instr_second_issue_ld_a0;

// For |fetch/instr$sll_rslt.
logic [31:0] FETCH_Instr_sll_rslt_a0;

// For |fetch/instr$slli_rslt.
logic [31:0] FETCH_Instr_slli_rslt_a0;

// For |fetch/instr$slt_rslt.
logic [31:0] FETCH_Instr_slt_rslt_a0;

// For |fetch/instr$slti_rslt.
logic [31:0] FETCH_Instr_slti_rslt_a0;

// For |fetch/instr$sltiu_rslt.
logic [31:0] FETCH_Instr_sltiu_rslt_a0;

// For |fetch/instr$sltu_rslt.
logic [31:0] FETCH_Instr_sltu_rslt_a0;

// For |fetch/instr$spec_ld.
logic FETCH_Instr_spec_ld_a0,
      FETCH_Instr_spec_ld_a1;

// For |fetch/instr$sra_rslt.
logic [31:0] FETCH_Instr_sra_rslt_a0;

// For |fetch/instr$srai_intermediate_rslt.
logic [31:0] FETCH_Instr_srai_intermediate_rslt_a0;

// For |fetch/instr$srai_rslt.
logic [31:0] FETCH_Instr_srai_rslt_a0;

// For |fetch/instr$srl_rslt.
logic [31:0] FETCH_Instr_srl_rslt_a0;

// For |fetch/instr$srli_intermediate_rslt.
logic [31:0] FETCH_Instr_srli_intermediate_rslt_a0;

// For |fetch/instr$srli_rslt.
logic [31:0] FETCH_Instr_srli_rslt_a0;

// For |fetch/instr$st.
logic FETCH_Instr_st_a0;

// For |fetch/instr$st_cond.
logic FETCH_Instr_st_cond_a0;

// For |fetch/instr$st_mask.
logic [3:0] FETCH_Instr_st_mask_a0;

// For |fetch/instr$st_reg_value.
logic [31:0] FETCH_Instr_st_reg_value_a0;

// For |fetch/instr$st_value.
logic [31:0] FETCH_Instr_st_value_a0;

// For |fetch/instr$sub_rslt.
logic [31:0] FETCH_Instr_sub_rslt_a0;

// For |fetch/instr$taken.
logic FETCH_Instr_taken_a0;

// For |fetch/instr$time_unit_expires.
logic FETCH_Instr_time_unit_expires_a0;

// For |fetch/instr$trap_target.
logic [31:0] FETCH_Instr_trap_target_a0,
             FETCH_Instr_trap_target_a1;

// For |fetch/instr$unnatural_addr_trap.
logic FETCH_Instr_unnatural_addr_trap_a0;

// For |fetch/instr$upd_csr_cycle.
logic [31:0] FETCH_Instr_upd_csr_cycle_a0;

// For |fetch/instr$upd_csr_cycleh.
logic [31:0] FETCH_Instr_upd_csr_cycleh_a0;

// For |fetch/instr$upd_csr_instret.
logic [31:0] FETCH_Instr_upd_csr_instret_a0;

// For |fetch/instr$upd_csr_instreth.
logic [31:0] FETCH_Instr_upd_csr_instreth_a0;

// For |fetch/instr$upd_csr_time.
logic [31:0] FETCH_Instr_upd_csr_time_a0;

// For |fetch/instr$upd_csr_timeh.
logic [31:0] FETCH_Instr_upd_csr_timeh_a0;

// For |fetch/instr$valid_csr.
logic FETCH_Instr_valid_csr_a0;

// For |fetch/instr$valid_decode.
logic FETCH_Instr_valid_decode_a0;

// For |fetch/instr$valid_decode_branch.
logic FETCH_Instr_valid_decode_branch_a0;

// For |fetch/instr$valid_exe.
logic FETCH_Instr_valid_exe_a0;

// For |fetch/instr$valid_ld.
logic FETCH_Instr_valid_ld_a0,
      FETCH_Instr_valid_ld_a1;

// For |fetch/instr$valid_st.
logic FETCH_Instr_valid_st_a0;

// For |fetch/instr$would_second_issue.
logic FETCH_Instr_would_second_issue_a0;

// For |fetch/instr$wr_reg.
logic [4:0] FETCH_Instr_wr_reg_a0;

// For |fetch/instr$xor_rslt.
logic [31:0] FETCH_Instr_xor_rslt_a0;

// For |fetch/instr$xori_rslt.
logic [31:0] FETCH_Instr_xori_rslt_a0;

// For |fetch/instr/orig_inst$dest_reg.
logic [4:0] FETCH_Instr_OrigInst_dest_reg_a0;

// For |fetch/instr/orig_inst$pc.
logic [31:0] FETCH_Instr_OrigInst_pc_a0;

// For |fetch/instr/orig_load_inst$addr.
logic [1:0] FETCH_Instr_OrigLoadInst_addr_a0;

// For |fetch/instr/orig_load_inst$dest_reg.
logic [4:0] FETCH_Instr_OrigLoadInst_dest_reg_a0;

// For |fetch/instr/orig_load_inst$g0_spec_ld_cond.
logic FETCH_Instr_OrigLoadInst_g0_spec_ld_cond_a0;

// For |fetch/instr/orig_load_inst$ld_data.
logic [31:0] FETCH_Instr_OrigLoadInst_ld_data_a0;

// For |fetch/instr/orig_load_inst$ld_mask.
logic [3:0] FETCH_Instr_OrigLoadInst_ld_mask_a0;

// For |fetch/instr/orig_load_inst$ld_rslt.
logic [31:0] FETCH_Instr_OrigLoadInst_ld_rslt_a0;

// For |fetch/instr/orig_load_inst$ld_st_half.
logic FETCH_Instr_OrigLoadInst_ld_st_half_a0;

// For |fetch/instr/orig_load_inst$ld_st_word.
logic FETCH_Instr_OrigLoadInst_ld_st_word_a0;

// For |fetch/instr/orig_load_inst$pc.
logic [31:0] FETCH_Instr_OrigLoadInst_pc_a0;

// For |fetch/instr/orig_load_inst$raw_funct3.
logic [2:2] FETCH_Instr_OrigLoadInst_raw_funct3_a0;

// For |fetch/instr/orig_load_inst$sign_bit.
logic FETCH_Instr_OrigLoadInst_sign_bit_a0;

// For |fetch/instr/orig_load_inst$spec_ld.
logic FETCH_Instr_OrigLoadInst_spec_ld_a0;

// For |fetch/instr/orig_load_inst$spec_ld_cond.
logic FETCH_Instr_OrigLoadInst_spec_ld_cond_a0;

// For |fetch/instr/regs$pending.
logic FETCH_Instr_Regs_pending_n1 [31:1],
      FETCH_Instr_Regs_pending_a0 [31:1];

// For |fetch/instr/regs$value.
logic [31:0] FETCH_Instr_Regs_value_a0 [31:1];

// For |fetch/instr/src$replay.
logic [2:1] FETCH_Instr_Src_replay_a0;

// For |fetch/instr/src$unconditioned_is_reg.
logic FETCH_Instr_Src_unconditioned_is_reg_a0 [2:1];

// For |fetch/instr/src$unconditioned_reg.
logic [4:0] FETCH_Instr_Src_unconditioned_reg_a0 [2:1];

// For |fetch/instr/src$unconditioned_reg_value.
logic [31:0] FETCH_Instr_Src_unconditioned_reg_value_a0 [2:1];

// For |fetch/instr_mem$instr_str.
logic [40*8-1:0] FETCH_InstrMem_instr_str_a0 [13:0];




   //
   // Scope: |fetch
   //

      // Staging of $Cnt.
      always_ff @(posedge clk) FETCH_Cnt_n1[7:0] <= FETCH_Cnt_n2[7:0];

      // Staging of $reset.
      always_ff @(posedge clk) FETCH_reset_a0 <= FETCH_reset_n1;


      //
      // Scope: /instr
      //

         // Staging of $GoodPathMask.
         always_ff @(posedge clk) FETCH_Instr_GoodPathMask_a0[1+1:0] <= FETCH_Instr_GoodPathMask_n1[1+1:0];

         // Staging of $Pc.
         always_ff @(posedge clk) FETCH_Instr_Pc_a0[31:0] <= FETCH_Instr_Pc_n1[31:0];

         // Staging of $RemainingCyclesWithinTimeUnit.
         always_ff @(posedge clk) FETCH_Instr_RemainingCyclesWithinTimeUnit_a0[30-1:0] <= FETCH_Instr_RemainingCyclesWithinTimeUnit_n1[30-1:0];

         // Staging of $aborting_trap.
         always_ff @(posedge clk) FETCH_Instr_aborting_trap_a1 <= FETCH_Instr_aborting_trap_a0;

         // Staging of $addr.
         always_ff @(posedge clk) FETCH_Instr_addr_a1[1:0] <= FETCH_Instr_addr_a0[1:0];

         // Staging of $csr_cycle.
         always_ff @(posedge clk) FETCH_Instr_csr_cycle_a0[31:0] <= FETCH_Instr_csr_cycle_n1[31:0];

         // Staging of $csr_cycleh.
         always_ff @(posedge clk) FETCH_Instr_csr_cycleh_a0[31:0] <= FETCH_Instr_csr_cycleh_n1[31:0];

         // Staging of $csr_instret.
         always_ff @(posedge clk) FETCH_Instr_csr_instret_a0[31:0] <= FETCH_Instr_csr_instret_n1[31:0];

         // Staging of $csr_instreth.
         always_ff @(posedge clk) FETCH_Instr_csr_instreth_a0[31:0] <= FETCH_Instr_csr_instreth_n1[31:0];

         // Staging of $csr_time.
         always_ff @(posedge clk) FETCH_Instr_csr_time_a0[31:0] <= FETCH_Instr_csr_time_n1[31:0];

         // Staging of $csr_timeh.
         always_ff @(posedge clk) FETCH_Instr_csr_timeh_a0[31:0] <= FETCH_Instr_csr_timeh_n1[31:0];

         // Staging of $dest_reg.
         always_ff @(posedge clk) FETCH_Instr_dest_reg_a1[4:0] <= FETCH_Instr_dest_reg_a0[4:0];

         // Staging of $ld_data.
         always_ff @(posedge clk) FETCH_Instr_ld_data_a1[31:0] <= FETCH_Instr_ld_data_a0[31:0];

         // Staging of $ld_st_half.
         always_ff @(posedge clk) FETCH_Instr_ld_st_half_a1 <= FETCH_Instr_ld_st_half_a0;

         // Staging of $ld_st_word.
         always_ff @(posedge clk) FETCH_Instr_ld_st_word_a1 <= FETCH_Instr_ld_st_word_a0;

         // Staging of $no_fetch.
         always_ff @(posedge clk) FETCH_Instr_no_fetch_a1 <= FETCH_Instr_no_fetch_a0;

         // Staging of $non_aborting_trap.
         always_ff @(posedge clk) FETCH_Instr_non_aborting_trap_a1 <= FETCH_Instr_non_aborting_trap_a0;

         // Staging of $non_pipelined.
         always_ff @(posedge clk) FETCH_Instr_non_pipelined_a1 <= FETCH_Instr_non_pipelined_a0;

         // Staging of $pc.
         always_ff @(posedge clk) FETCH_Instr_pc_a1[31:0] <= FETCH_Instr_pc_a0[31:0];

         // Staging of $pc_inc.
         always_ff @(posedge clk) FETCH_Instr_pc_inc_a1[31:0] <= FETCH_Instr_pc_inc_a0[31:0];

         // Staging of $raw_funct3.
         always_ff @(posedge clk) FETCH_Instr_raw_funct3_a1[2] <= FETCH_Instr_raw_funct3_a0[2];

         // Staging of $replay.
         always_ff @(posedge clk) FETCH_Instr_replay_a1 <= FETCH_Instr_replay_a0;

         // Staging of $reset.
         always_ff @(posedge clk) FETCH_Instr_reset_a0 <= FETCH_Instr_reset_n1;

         // Staging of $second_issue.
         always_ff @(posedge clk) FETCH_Instr_second_issue_a1 <= FETCH_Instr_second_issue_a0;

         // Staging of $spec_ld.
         always_ff @(posedge clk) FETCH_Instr_spec_ld_a1 <= FETCH_Instr_spec_ld_a0;

         // Staging of $trap_target.
         always_ff @(posedge clk) FETCH_Instr_trap_target_a1[31:0] <= FETCH_Instr_trap_target_a0[31:0];

         // Staging of $valid_ld.
         always_ff @(posedge clk) FETCH_Instr_valid_ld_a1 <= FETCH_Instr_valid_ld_a0;


         //
         // Scope: /orig_load_inst
         //

            // Staging of an unconditioned version of a condition signal.
            assign FETCH_Instr_OrigLoadInst_g0_spec_ld_cond_a0 = FETCH_Instr_OrigLoadInst_spec_ld_cond_a0 && FETCH_Instr_second_issue_ld_a0;



         //
         // Scope: /regs[31:1]
         //
         for (regs = 1; regs <= 31; regs++) begin : L1gen_FETCH_Instr_Regs
            // Staging of $pending.
            always_ff @(posedge clk) FETCH_Instr_Regs_pending_a0[regs] <= FETCH_Instr_Regs_pending_n1[regs];

         end

         //
         // Scope: /src[2:1]
         //
         for (src = 1; src <= 2; src++) begin : L1gen_FETCH_Instr_Src
            // Staging of $dummy.
            always_ff @(posedge clk) L1c_FETCH_Instr_Src[src].L1_dummy_a1 <= L1c_FETCH_Instr_Src[src].L1_dummy_a0;

         end



// ---------- Generated Code Ends ----------
//_\TLV
   /* verilator lint_off UNOPTFLAT */
   //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 6361   // Instantiated from tt_um_warpv.tlv, 61 as: m5+warpv_top()
      /* verilator lint_on WIDTH */  // Let's be strict about bit widths.
      //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 6363 as: m5+ifelse(m5__l(6363)m5_calc(m5_get(NUM_CORES) > 1), 1,
         //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 6386   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__1.
            // Single Core.
            
            
            //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 3771   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 6390 as: m5+cpu(/top)
            
            
            
               //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 3775 as: m5+ifelse(m5__l(3775)m5_call(if_var_ndef,OP5_00000_TYPE, 1, 0), 1,
                  //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 3776   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__2.
                     //_\source M5-FN-riscv_gen 0   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 3777 as: m5+call(m5_get(isa)⌈_gen⌉)
                        
                     //_\end_source
                  //_\end_source
               //_\end_source
               // Instruction memory and fetch of $raw.
               //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1684   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 3780 as: m5+call(m5_get(IMEM_MACRO_NAME), m5_get(PROG_NAME))
               
                  // ==============
                  // IMem and Fetch
                  // ==============
               
                  /* DMEM_STYLE: ARRAY, FORMAL: 0 */
                  //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1691 as: m5+ifelse(m5_get(FORMAL), 1,
                     //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ifelse.
                        //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ifelse.
                           //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ifelse.
                              //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1749   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__7.
                                 // Default to HARDCODED_ARRAY
                                 // For simulation
                                 // --------------
                                             
                                 // Define the program.
                                 //_\source M5-FN-riscv_cnt10_prog 0   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1755 as: m5+call(⌈riscv_⌉cnt10⌈_prog⌉)
                                    // Inst #0: ORI t2\end_source
                                 /*SV_plus*/
                                    // The program in an instruction memory.
                                    logic [31:0] instrs [0:14-1];
                                    logic [40*8-1:0] instr_strs [0:14];
                                             
                                    assign instrs[0] = {12'b000000000000, 5'd0, 3'b110, 5'd7, 7'b0010011}; assign instrs[1] = {12'b000000000001, 5'd0, 3'b110, 5'd5, 7'b0010011}; assign instrs[2] = {12'b000000001010, 5'd0, 3'b110, 5'd12, 7'b0010011}; assign instrs[3] = {12'b000000000000, 5'd0, 3'b110, 5'd10, 7'b0010011}; assign instrs[4] = {7'b0000000, 5'd10, 5'd5, 3'b000, 5'd10, 7'b0110011}; assign instrs[5] = {7'b0000000, 5'd10, 5'd7, 3'b010, 5'b00000, 7'b0100011}; assign instrs[6] = {12'b000000000001, 5'd5, 3'b000, 5'd5, 7'b0010011}; assign instrs[7] = {12'b000000000100, 5'd7, 3'b000, 5'd7, 7'b0010011}; assign instrs[8] = {1'b1, 6'b111111, 5'd12, 5'd5, 3'b100, 4'b1000, 1'b1, 7'b1100011}; assign instrs[9] = {12'b111111111100, 5'd7, 3'b010, 5'd6, 7'b0000011}; assign instrs[10] = {12'b000000101101, 5'd0, 3'b000, 5'd11, 7'b0010011}; assign instrs[11] = {1'b0, 6'b000000, 5'd11, 5'd6, 3'b000, 4'b0100, 1'b0, 7'b1100011}; assign instrs[12] = {7'b0000000, 5'd0, 5'd11, 3'b000, 5'd11, 7'b0110011}; assign instrs[13] = {7'b0000000, 5'd0, 5'd6, 3'b000, 5'd6, 7'b0110011}; 
                                             
                                             
                                    // String representations of the instructions for debug.
                                    assign instr_strs[0] = "(I) ORI t2,zero,0                       "; assign instr_strs[1] = "(I) ORI t0,zero,1                       "; assign instr_strs[2] = "(I) ORI a2,zero,10                      "; assign instr_strs[3] = "(I) ORI a0,zero,0                       "; assign instr_strs[4] = "(R) ADD a0,t0,a0                        "; assign instr_strs[5] = "(S) SW t2,a0,0                          "; assign instr_strs[6] = "(I) ADDI t0,t0,1                        "; assign instr_strs[7] = "(I) ADDI t2,t2,4                        "; assign instr_strs[8] = "(B) BLT t0,a2,loop                      "; assign instr_strs[9] = "(I) LW t1,t2,-4                         "; assign instr_strs[10] = "(I) ADDI a1,zero,0x2d                   "; assign instr_strs[11] = "(B) BEQ t1,a1,pass                      "; assign instr_strs[12] = "(R) ADD a1,a1,zero                      "; assign instr_strs[13] = "(R) ADD t1,t1,zero                      "; 
                                             
                                    assign instr_strs[14] = "END                                     ";
                                             
                                 //_|fetch
                                    //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1770 as: m5+ifelse(m5_get(VIZ), 1,
                                       //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1771   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__8.
                                          for (instr_mem = 0; instr_mem <= 13; instr_mem++) begin : L1_FETCH_InstrMem //_/instr_mem

                                             // For $instr.
                                             logic [31:0] L1_instr_a0;

                                             //_@0
                                                assign L1_instr_a0[31:0] = instrs[instr_mem];
                                                assign FETCH_InstrMem_instr_str_a0[instr_mem][40*8-1:0] = instr_strs[instr_mem];
                                          end
                                       //_\end_source
                                    //_\end_source
                                    //_@0
                                       //_?$fetch
                                          assign FETCH_fetch_word_a0[31:0] = instrs[FETCH_Instr_Pc_a0[5:2]];
                              //_\end_source
                           //_\end_source
                        //_\end_source
                     //_\end_source
                  //_\end_source
               //_\end_source
            
               // /=========\
               // | The CPU |
               // \=========/
            
               //_|fetch
                  // Provide a longer reset to cover the pipeline depth.
                  //_@-1
                     assign FETCH_soft_reset_n1 = (1'b0) || reset;
                     assign FETCH_Cnt_n2[7:0] = FETCH_soft_reset_n1   ? 8'b0 :       // reset
                                  FETCH_Cnt_n1 == 8'hFF ? 8'hFF :      // max out to avoid wrapping
                                                  FETCH_Cnt_n1 + 8'b1; // increment
                     assign FETCH_reset_n1 = FETCH_soft_reset_n1 || FETCH_Cnt_n1 < 5;
                  //_@0
                     assign FETCH_fetch_a0 = ! FETCH_reset_a0 && ! FETCH_Instr_no_fetch_a0;
            
                  //_/instr
                     //_@-1
                        assign FETCH_Instr_reset_n1 = FETCH_reset_n1;
                     //_@0
                        assign FETCH_Instr_fetch_a0 = FETCH_fetch_a0;
            
                     //_@0
            
                        // ========
                        // Overview
                        // ========
            
                        // Terminology:
                        //
                        // Instruction: An instruction, as viewed by the CPU pipeline (i.e. ld and returning_ld are separate instructions,
                        //              and the returning_ld and the instruction it clobbers are one in the same).
                        // ISA Instruction: An instruction, as defined by the ISA.
                        // Good-Path (vs. Bad-Path): On the proper flow of execution of the program, excluding aborted instructions.
                        // Path (of an instruction): The sequence of instructions that led to a particular instruction.
                        // Current Path: The sequence of instructions fetched by next-PC logic that are not known to be bad-path.
                        // Redirect: Adjust the PC from the predicted next-PC.
                        // Redirect Shadow: Between the instruction causing the redirect and the redirect target instruction.
                        // Bubbles: The cycles in the redirect shadow.
                        // Commit: Results are made visible to subsequent instructions.
                        // Abort: Do not commit. All aborts are also redirects and put the instruction on bad path. Non-aborting
                        //        redirects do not mark the triggering instruction as bad-path. Aborts mask future redirects on the
                        //        aborted instruction.
                        // Retire: Commit results of an ISA instruction.
            
                        // Control flow:
                        //
                        // Redirects include (earliest to latest):
                        //   o Returning load: (aborting) A returning load clobbers an instruction and takes its slot, resulting in a
                        //                     one-cycle redirect to repeat the clobbered instruction.
                        //   o More-to-do: This is currently specific to RISC-V C-ext. When the first instruction in the 32-bit fetch
                        //                 unit is a 16-bit instruction this redirect fetches the second 16-bit instruction.
                        //   o Predict-taken branch: A predicted-taken branch must determine the target before it can redirect the PC.
                        //                           (This might be followed up by a mispredition.)
                        //   o Replay: (aborting) Replay the same instruction (because a source register is pending (awaiting a long-latency/2nd issuing instruction))
                        //   o Jump: A jump instruction.
                        //   o Mispredicted branch: A branch condition was mispredicted.
                        //   o Aborting traps: (aborting) illegal instructions, others?
                        //   o Non-aborting traps: misaligned PC target
            
                        // ==============
                        // Redirect Logic
                        // ==============
            
                        // PC logic will redirect the PC for conditions on current-path instructions. PC logic keeps track of which
                        // instructions are on the current path with a $GoodPathMask. $GoodPathMask[n] of an instruction indicates
                        // whether the instruction n instructions prior to this instruction is on its path.
                        //
                        //                 $GoodPathMask for Redir'edX => {o,X,o,y,y,y,o,o} == {1,1,1,1,0,0,1,1}
                        // Waterfall View: |
                        //                 V
                        // 0:       oooooooo                  Good-path
                        // 1: InstX  ooooooXo  (Non-aborting) Good-path
                        // 2:         ooooooxx
                        // 3: InstY    ooYyyxxx  (Aborting)
                        // 4: InstZ     ooyyxZxx
                        // 5: Redir'edY  oyyxxxxx
                        // 6: TargetY     ooxxxxxx
                        // 7: Redir'edX    oxxxxxxx
                        // 8: TargetX       oooooooo          Good-path
                        // 9: Not redir'edZ  oooooooo         Good-path
                        //
                        // Above depicts a waterfall diagram where three triggering redirection conditions X, Y, and Z are detected on three different
                        // instructions. A trigger in the 1st depicted stage, m5-NEXT_PC_STAGE, results in a zero-bubble redirect so it would be
                        // a condition that is factored directly into the next-PC logic of the triggering instruction, and it would have
                        // no impact on the $GoodPathMask.
                        //
                        // Waveform View:
                        //
                        //   Inst 0123456789
                        //        ---------- /
                        // GPM[7]        ooxxxxxxoo
                        // GPM[6]       oXxxxxxxoo
                        // GPM[5]      oooxZxxxoo
                        // GPM[4]     oooyxxxxoo
                        // GPM[3]    oooyyxxxoo
                        // GPM[2]   oooYyyxxoo
                        // GPM[1]  oooooyoxoo
                        // GPM[0] oooooooooo
                        //          /
                        //         Triggers for InstY
                        //
                        // In the waveform view, the mask shifts up each cycle, as instructions age, and trigger conditions mask instructions
                        // in the shadow, down to the redirect target (GPM[0]).
                        //
                        // Terminology:
                        //   Triggering instruction: The instruction on which the condition is detected.
                        //   Redirected instruction: The instruction whose next PC is redirected.
                        //   Redirection target instruction: The first new-path instruction resulting from the redirection.
                        //
                        // Above, Y redirects first, though it is for a later instruction than X. The redirections for X and Y are taken
                        // because their instructions are on the path of the redirected instructions. Z is not on the path of its
                        // potentially-redirected instruction, so no redirection happens.
                        //
                        // For simultaneous conditions on different instructions, the PC must redirect to the earlier instruction's
                        // redirect target, so later-stage redirects take priority in the PC-mux.
                        //
                        // Aborting redirects result in the aborting instruction being marked as bad-path. Aborted instructions will
                        // not commit. Subsequent redirect conditions on aborting instructions are ignored. (For conditions within the
                        // same stage, this is accomplished by the PC-mux prioritization.)
            
            
                        // Macros are defined elsewhere based on the ordered set of conditions that generate code here.
            
                        // Redirect Shadow
                        // A mask of stages ahead of this one (older) in which instructions are on the path of this instruction.
                        // Index 1 is ahead by 1, etc.
                        // In the example above, $GoodPathMask for Redir'edX == {0,0,0,0,1,1,0,0}
                        //     (Looking up in the waterfall diagram from its first "o", in reverse order {o,X,o,o,y,y,o,o}.)
                        // The LSB is fetch-valid. It only exists for use by the m5-prev_instr_valid_through macro.
                        assign FETCH_Instr_next_good_path_mask_a0[1+1:0] =
                           // Shift up and mask w/ redirect conditions.
                           {FETCH_Instr_GoodPathMask_a0[1:0]
                            // & terms for each condition (order doesn't matter since masks are the same within a cycle)
                             & (FETCH_Instr_no_fetch_cond_a0 ? {{1{1'b1}}, {1{1'b0}}} : {2{1'b1}}) & (FETCH_Instr_second_issue_cond_a0 ? {{1{1'b1}}, {1{1'b0}}} : {2{1'b1}}) & (FETCH_Instr_replay_cond_a0 ? {{1{1'b1}}, {1{1'b0}}} : {2{1'b1}}) & (FETCH_Instr_jump_cond_a0 ? {{2{1'b1}}, {0{1'b0}}} : {2{1'b1}}) & (FETCH_Instr_mispred_branch_cond_a0 ? {{2{1'b1}}, {0{1'b0}}} : {2{1'b1}}) & (FETCH_Instr_indirect_jump_cond_a0 ? {{2{1'b1}}, {0{1'b0}}} : {2{1'b1}}) & (FETCH_Instr_non_pipelined_cond_a0 ? {{1{1'b1}}, {1{1'b0}}} : {2{1'b1}}) & (FETCH_Instr_aborting_trap_cond_a0 ? {{0{1'b1}}, {2{1'b0}}} : {2{1'b1}}) & (FETCH_Instr_non_aborting_trap_cond_a0 ? {{1{1'b1}}, {1{1'b0}}} : {2{1'b1}}),
                            1'b1}; // Shift in 1'b1 (fetch-valid).
            
                        assign FETCH_Instr_GoodPathMask_n1[1+1:0] =
                           FETCH_Instr_reset_n1 ? 3'b0 :  // All bad-path (through self) on reset (next mask based on next reset).
                           FETCH_Instr_next_good_path_mask_a0;
            
                        //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 3922 as: m5+ifelse(m5_get(FORMAL), 1,
                           
                        //_\end_source
            
            
                        assign FETCH_Instr_second_issue_a0 = (FETCH_Instr_second_issue_ld_a0 );
                        assign FETCH_Instr_commit_second_issue_a0 = FETCH_Instr_second_issue_a0;  // TODO: Updating this to have a speculative and non-speculative version.
                                                               //       Note that I don't think $commit asserts for $second_issue.
                        // Recirculate returning load or the div_mul_result from /orig_inst scope
            
                        // Next PC
                        assign FETCH_Instr_pc_inc_a0[31:0] = FETCH_Instr_Pc_a0 + 32'd4;
                        // Current parsing does not allow concatenated state on left-hand-side, so, first, a non-state expression.
                        //_\source M5-FN-redirect_conditions 0   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 3944 as: m5+redirect_conditions()
                           assign FETCH_Instr_non_aborting_trap_cond_a0 = (FETCH_Instr_non_aborting_trap_a1 && !(1'b0 || FETCH_Instr_no_fetch_a1 || FETCH_Instr_second_issue_a1 || FETCH_Instr_replay_a1 || FETCH_Instr_aborting_trap_a1) && FETCH_Instr_GoodPathMask_a0[1]);
                           assign FETCH_Instr_aborting_trap_cond_a0 = (FETCH_Instr_aborting_trap_a1 && !(1'b0 || FETCH_Instr_no_fetch_a1 || FETCH_Instr_second_issue_a1 || FETCH_Instr_replay_a1) && FETCH_Instr_GoodPathMask_a0[1]);
                           assign FETCH_Instr_non_pipelined_cond_a0 = (FETCH_Instr_non_pipelined_a1 && !(1'b0 || FETCH_Instr_no_fetch_a1 || FETCH_Instr_second_issue_a1 || FETCH_Instr_replay_a1) && FETCH_Instr_GoodPathMask_a0[1]);
                           assign FETCH_Instr_indirect_jump_cond_a0 = (FETCH_Instr_indirect_jump_a0 && !(1'b0 || FETCH_Instr_no_fetch_a0 || FETCH_Instr_second_issue_a0 || FETCH_Instr_replay_a0) && FETCH_Instr_GoodPathMask_a0[0]);
                           assign FETCH_Instr_mispred_branch_cond_a0 = (FETCH_Instr_mispred_branch_a0 && !(1'b0 || FETCH_Instr_no_fetch_a0 || FETCH_Instr_second_issue_a0 || FETCH_Instr_replay_a0) && FETCH_Instr_GoodPathMask_a0[0]);
                           assign FETCH_Instr_jump_cond_a0 = (FETCH_Instr_jump_a0 && !(1'b0 || FETCH_Instr_no_fetch_a0 || FETCH_Instr_second_issue_a0 || FETCH_Instr_replay_a0) && FETCH_Instr_GoodPathMask_a0[0]);
                           assign FETCH_Instr_replay_cond_a0 = (FETCH_Instr_replay_a0 && !(1'b0 || FETCH_Instr_no_fetch_a0 || FETCH_Instr_second_issue_a0) && FETCH_Instr_GoodPathMask_a0[0]);
                           assign FETCH_Instr_second_issue_cond_a0 = (FETCH_Instr_second_issue_a0 && !(1'b0 || FETCH_Instr_no_fetch_a0) && FETCH_Instr_GoodPathMask_a0[0]);
                           assign FETCH_Instr_no_fetch_cond_a0 = (FETCH_Instr_no_fetch_a0 && !(1'b0) && FETCH_Instr_GoodPathMask_a0[0]);
                           
                        //_\end_source
                        // TODO: Remove $next_no_fetch.
                        assign {FETCH_Instr_next_pc_a0[31:0], FETCH_Instr_next_no_fetch_a0} =
                           FETCH_Instr_reset_a0 ? {31'b0, 2'b0} :
                           // ? : terms for each condition (order does matter)
                           FETCH_Instr_non_aborting_trap_cond_a0 ? {FETCH_Instr_trap_target_a1, 1'b0} : FETCH_Instr_aborting_trap_cond_a0 ? {FETCH_Instr_trap_target_a1, 1'b0} : FETCH_Instr_non_pipelined_cond_a0 ? {FETCH_Instr_pc_inc_a1, 1'b1} : FETCH_Instr_indirect_jump_cond_a0 ? {FETCH_Instr_indirect_jump_target_a0, 1'b0} : FETCH_Instr_mispred_branch_cond_a0 ? {FETCH_Instr_branch_redir_pc_a0, 1'b0} : FETCH_Instr_jump_cond_a0 ? {FETCH_Instr_jump_target_a0, 1'b0} : FETCH_Instr_replay_cond_a0 ? {FETCH_Instr_Pc_a0, 1'b0} : FETCH_Instr_second_issue_cond_a0 ? {FETCH_Instr_Pc_a0, 1'b0} : FETCH_Instr_no_fetch_cond_a0 ? {FETCH_Instr_Pc_a0, 1'b1} : 
                                      ({FETCH_Instr_pc_inc_a0, 1'b0});
                        // Then as state.
                        assign FETCH_Instr_Pc_n1[31:0] = FETCH_Instr_next_pc_a0;
                        assign FETCH_Instr_no_fetch_a0 = 1'b0;
                        `BOGUS_USE(FETCH_Instr_next_no_fetch_a0)
            
                     //_@0
            
                        // ======
                        // DECODE
                        // ======
            
                        //_?$second_issue
                           //_/orig_inst
                              // pull values from /orig_load_inst or /hold_inst depending on which second issue
                              assign {FETCH_Instr_OrigInst_dest_reg_a0[4:0], FETCH_Instr_OrigInst_pc_a0[31:0]} = FETCH_Instr_second_issue_ld_a0 ? {FETCH_Instr_OrigLoadInst_dest_reg_a0, FETCH_Instr_OrigLoadInst_pc_a0} : {FETCH_Instr_OrigLoadInst_dest_reg_a0, FETCH_Instr_OrigLoadInst_pc_a0} /* default case is invalid, but this choice should enable logic to reduce well */;
                              for (src = 1; src <= 2; src++) begin : L1_FETCH_Instr_OrigInst_Src //_/src

                                 // For $dummy.
                                 logic L1_dummy_a0;

                                 assign {L1_dummy_a0} = FETCH_Instr_second_issue_ld_a0 ? {L1_FETCH_Instr_OrigLoadInst_Src[src].L1_dummy_a0} : {L1_FETCH_Instr_OrigLoadInst_Src[src].L1_dummy_a0};
                              end
                              //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 3968 as: m5+ifelse(m5_get(EXT_F), 1,
                                 
                              //_\end_source
            
                        // Decode of the fetched instruction
                        assign FETCH_Instr_valid_decode_a0 = FETCH_Instr_fetch_a0;  // Always decode if we fetch.
                        assign FETCH_Instr_valid_decode_branch_a0 = FETCH_Instr_valid_decode_a0 && FETCH_Instr_branch_a0;
            
                        //_?$valid_decode
                           //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 3981 as: m5+ifelse(m5_get(MORE_TO_DO_SUPPORTED), 1,
                              //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 3986   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__12.
                                 // Directly connect the fetch word to the instruction.
                                 assign FETCH_Instr_raw_a0[31:0] = FETCH_fetch_word_a0;
                              //_\end_source
                           //_\end_source
            
                        // A load that will return later.
                        //$split_ld = $spec_ld && 1'b1;
                        // Instantiate the program.
                        //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1960   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 3994 as: m5+call(m5_get(isa)⌈_decode⌉)
                           //_?$valid_decode
                              // =================================
                        
                              // Extract fields of $raw (instruction) into $raw_<field>[x:0].
                              assign {FETCH_Instr_raw_funct7_a0[6:0], FETCH_Instr_raw_rs2_a0[4:0], FETCH_Instr_raw_rs1_a0[4:0], FETCH_Instr_raw_funct3_a0[2:0], FETCH_Instr_raw_rd_a0[4:0], FETCH_Instr_raw_op5_a0[4:0], FETCH_Instr_raw_op2_a0[1:0]} = FETCH_Instr_raw_a0;
                              `BOGUS_USE(FETCH_Instr_raw_op2_a0)  // Delete once it's used.
                              // Extract immediate fields into type-specific signals.
                              // (User ISA Manual 2.2, Fig. 2.4)
                              assign FETCH_Instr_raw_i_imm_a0[31:0] = {{21{FETCH_Instr_raw_a0[31]}}, FETCH_Instr_raw_a0[30:20]};
                              assign FETCH_Instr_raw_s_imm_a0[31:0] = {{21{FETCH_Instr_raw_a0[31]}}, FETCH_Instr_raw_a0[30:25], FETCH_Instr_raw_a0[11:7]};
                              assign FETCH_Instr_raw_b_imm_a0[31:0] = {{20{FETCH_Instr_raw_a0[31]}}, FETCH_Instr_raw_a0[7], FETCH_Instr_raw_a0[30:25], FETCH_Instr_raw_a0[11:8], 1'b0};
                              assign FETCH_Instr_raw_u_imm_a0[31:0] = {FETCH_Instr_raw_a0[31:12], {12{1'b0}}};
                              assign FETCH_Instr_raw_j_imm_a0[31:0] = {{12{FETCH_Instr_raw_a0[31]}}, FETCH_Instr_raw_a0[19:12], FETCH_Instr_raw_a0[20], FETCH_Instr_raw_a0[30:21], 1'b0};
                              // Extract other type/instruction-specific fields.
                              assign FETCH_Instr_raw_shamt_a0[6:0] = FETCH_Instr_raw_a0[26:20];
                              assign FETCH_Instr_raw_aq_a0 = FETCH_Instr_raw_a0[26];
                              assign FETCH_Instr_raw_rl_a0 = FETCH_Instr_raw_a0[25];
                              assign FETCH_Instr_raw_rs3_a0[4:0] = FETCH_Instr_raw_a0[31:27];
                              assign FETCH_Instr_raw_rm_a0[2:0] = FETCH_Instr_raw_funct3_a0;
                              `BOGUS_USE(FETCH_Instr_raw_shamt_a0 FETCH_Instr_raw_aq_a0 FETCH_Instr_raw_rl_a0 FETCH_Instr_raw_rs3_a0 FETCH_Instr_raw_rm_a0)  // Avoid "unused" messages. Remove these as they become used.
                        
                              // Instruction type decode
                              //_\source M5-FN-instr_types_decode 0   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1983 as: m5+instr_types_decode()
                                 /*SV_plus*/
                                    assign FETCH_Instr_is_i_type_a0 = (((0 | (1 << 5'b00000) | (1 << 5'b00001) | (1 << 5'b00100) | (1 << 5'b00110) | (1 << 5'b11001) | (1 << 5'b11100)) >> FETCH_Instr_raw_op5_a0) & 32'b1) != 32'b0; 
                                    assign FETCH_Instr_is_r_type_a0 = (((0 | (1 << 5'b01011) | (1 << 5'b01100) | (1 << 5'b01110) | (1 << 5'b10100)) >> FETCH_Instr_raw_op5_a0) & 32'b1) != 32'b0; 
                                    assign FETCH_Instr_is_r2_type_a0 = (((0) >> FETCH_Instr_raw_op5_a0) & 32'b1) != 32'b0; 
                                    assign FETCH_Instr_is_r4_type_a0 = (((0 | (1 << 5'b10000) | (1 << 5'b10001) | (1 << 5'b10010) | (1 << 5'b10011)) >> FETCH_Instr_raw_op5_a0) & 32'b1) != 32'b0; 
                                    assign FETCH_Instr_is_s_type_a0 = (((0 | (1 << 5'b01000) | (1 << 5'b01001)) >> FETCH_Instr_raw_op5_a0) & 32'b1) != 32'b0; 
                                    assign FETCH_Instr_is_b_type_a0 = (((0 | (1 << 5'b11000)) >> FETCH_Instr_raw_op5_a0) & 32'b1) != 32'b0; 
                                    assign FETCH_Instr_is_j_type_a0 = (((0 | (1 << 5'b11011)) >> FETCH_Instr_raw_op5_a0) & 32'b1) != 32'b0; 
                                    assign FETCH_Instr_is_u_type_a0 = (((0 | (1 << 5'b00101) | (1 << 5'b01101)) >> FETCH_Instr_raw_op5_a0) & 32'b1) != 32'b0; 
                                    assign FETCH_Instr_is___type_a0 = (((0 | (1 << 5'b00010) | (1 << 5'b00011) | (1 << 5'b00111) | (1 << 5'b01010) | (1 << 5'b01111) | (1 << 5'b10101) | (1 << 5'b10110) | (1 << 5'b10111) | (1 << 5'b11010) | (1 << 5'b11101) | (1 << 5'b11110) | (1 << 5'b11111)) >> FETCH_Instr_raw_op5_a0) & 32'b1) != 32'b0; 
                              //_\end_source
                        
                              // Instruction decode.
                              //_\source M5-FN-riscv_decode_expr 0   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1986 as: m5+riscv_decode_expr()
                                 assign FETCH_Instr_is_lui_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01101;
                                 assign FETCH_Instr_is_auipc_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00101;
                                 assign FETCH_Instr_is_jal_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11011;
                                 assign FETCH_Instr_is_jalr_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11001 && FETCH_Instr_raw_funct3_a0 == 3'b000;
                                 assign FETCH_Instr_is_beq_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11000 && FETCH_Instr_raw_funct3_a0 == 3'b000;
                                 assign FETCH_Instr_is_bne_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11000 && FETCH_Instr_raw_funct3_a0 == 3'b001;
                                 assign FETCH_Instr_is_blt_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11000 && FETCH_Instr_raw_funct3_a0 == 3'b100;
                                 assign FETCH_Instr_is_bge_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11000 && FETCH_Instr_raw_funct3_a0 == 3'b101;
                                 assign FETCH_Instr_is_bltu_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11000 && FETCH_Instr_raw_funct3_a0 == 3'b110;
                                 assign FETCH_Instr_is_bgeu_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11000 && FETCH_Instr_raw_funct3_a0 == 3'b111;
                                 assign FETCH_Instr_is_lb_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00000 && FETCH_Instr_raw_funct3_a0 == 3'b000;
                                 assign FETCH_Instr_is_lh_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00000 && FETCH_Instr_raw_funct3_a0 == 3'b001;
                                 assign FETCH_Instr_is_lw_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00000 && FETCH_Instr_raw_funct3_a0 == 3'b010;
                                 assign FETCH_Instr_is_lbu_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00000 && FETCH_Instr_raw_funct3_a0 == 3'b100;
                                 assign FETCH_Instr_is_lhu_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00000 && FETCH_Instr_raw_funct3_a0 == 3'b101;
                                 assign FETCH_Instr_is_sb_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01000 && FETCH_Instr_raw_funct3_a0 == 3'b000;
                                 assign FETCH_Instr_is_sh_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01000 && FETCH_Instr_raw_funct3_a0 == 3'b001;
                                 assign FETCH_Instr_is_sw_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01000 && FETCH_Instr_raw_funct3_a0 == 3'b010;
                                 assign FETCH_Instr_is_addi_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b000;
                                 assign FETCH_Instr_is_slti_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b010;
                                 assign FETCH_Instr_is_sltiu_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b011;
                                 assign FETCH_Instr_is_xori_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b100;
                                 assign FETCH_Instr_is_ori_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b110;
                                 assign FETCH_Instr_is_andi_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b111;
                                 assign FETCH_Instr_is_slli_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b001 && FETCH_Instr_raw_funct7_a0[6:1] == 6'b000000;
                                 assign FETCH_Instr_is_srli_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b101 && FETCH_Instr_raw_funct7_a0[6:1] == 6'b000000;
                                 assign FETCH_Instr_is_srai_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b101 && FETCH_Instr_raw_funct7_a0[6:1] == 6'b010000;
                                 assign FETCH_Instr_is_add_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b000 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000000;
                                 assign FETCH_Instr_is_sub_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b000 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0100000;
                                 assign FETCH_Instr_is_sll_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b001 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000000;
                                 assign FETCH_Instr_is_slt_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b010 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000000;
                                 assign FETCH_Instr_is_sltu_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b011 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000000;
                                 assign FETCH_Instr_is_xor_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b100 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000000;
                                 assign FETCH_Instr_is_srl_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b101 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000000;
                                 assign FETCH_Instr_is_sra_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b101 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0100000;
                                 assign FETCH_Instr_is_or_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b110 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000000;
                                 assign FETCH_Instr_is_and_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b111 && FETCH_Instr_raw_funct7_a0[6:0] == 7'b0000000;
                                 assign FETCH_Instr_is_csrrw_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11100 && FETCH_Instr_raw_funct3_a0 == 3'b001;
                                 assign FETCH_Instr_is_csrrs_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11100 && FETCH_Instr_raw_funct3_a0 == 3'b010;
                                 assign FETCH_Instr_is_csrrc_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11100 && FETCH_Instr_raw_funct3_a0 == 3'b011;
                                 assign FETCH_Instr_is_csrrwi_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11100 && FETCH_Instr_raw_funct3_a0 == 3'b101;
                                 assign FETCH_Instr_is_csrrsi_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11100 && FETCH_Instr_raw_funct3_a0 == 3'b110;
                                 assign FETCH_Instr_is_csrrci_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11100 && FETCH_Instr_raw_funct3_a0 == 3'b111;
                                 
                              //_\end_source
                        
                              //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1988 as: m5+ifelse(m5_get(EXT_M), 1,
                                 //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1995   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__14.
                                    assign FETCH_Instr_div_mul_a0 = 1'b0;
                                 //_\end_source
                              //_\end_source
                        
                              //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1999 as: m5+ifelse(m5_get(EXT_F), 1,
                                 
                              //_\end_source
                        
                              //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 2057 as: m5+ifelse(m5_get(EXT_B), 1,
                                 
                              //_\end_source
                        
                              assign FETCH_Instr_is_srli_srai_instr_a0 = FETCH_Instr_is_srli_instr_a0 || FETCH_Instr_is_srai_instr_a0;
                              // Some I-type instructions have a funct7 field rather than immediate bits, so these must factor into the illegal instruction expression explicitly.
                              assign FETCH_Instr_illegal_itype_with_funct7_a0 = ( FETCH_Instr_is_srli_srai_instr_a0  ) && | {FETCH_Instr_raw_funct7_a0[6], FETCH_Instr_raw_funct7_a0[4:0]};
                              assign FETCH_Instr_illegal_a0 = FETCH_Instr_illegal_itype_with_funct7_a0 ||
                                         (1'b1 && ! FETCH_Instr_is_lui_instr_a0 && ! FETCH_Instr_is_auipc_instr_a0 && ! FETCH_Instr_is_jal_instr_a0 && ! FETCH_Instr_is_jalr_instr_a0 && ! FETCH_Instr_is_beq_instr_a0 && ! FETCH_Instr_is_bne_instr_a0 && ! FETCH_Instr_is_blt_instr_a0 && ! FETCH_Instr_is_bge_instr_a0 && ! FETCH_Instr_is_bltu_instr_a0 && ! FETCH_Instr_is_bgeu_instr_a0 && ! FETCH_Instr_is_lb_instr_a0 && ! FETCH_Instr_is_lh_instr_a0 && ! FETCH_Instr_is_lw_instr_a0 && ! FETCH_Instr_is_lbu_instr_a0 && ! FETCH_Instr_is_lhu_instr_a0 && ! FETCH_Instr_is_sb_instr_a0 && ! FETCH_Instr_is_sh_instr_a0 && ! FETCH_Instr_is_sw_instr_a0 && ! FETCH_Instr_is_addi_instr_a0 && ! FETCH_Instr_is_slti_instr_a0 && ! FETCH_Instr_is_sltiu_instr_a0 && ! FETCH_Instr_is_xori_instr_a0 && ! FETCH_Instr_is_ori_instr_a0 && ! FETCH_Instr_is_andi_instr_a0 && ! FETCH_Instr_is_slli_instr_a0 && ! FETCH_Instr_is_srli_instr_a0 && ! FETCH_Instr_is_srai_instr_a0 && ! FETCH_Instr_is_add_instr_a0 && ! FETCH_Instr_is_sub_instr_a0 && ! FETCH_Instr_is_sll_instr_a0 && ! FETCH_Instr_is_slt_instr_a0 && ! FETCH_Instr_is_sltu_instr_a0 && ! FETCH_Instr_is_xor_instr_a0 && ! FETCH_Instr_is_srl_instr_a0 && ! FETCH_Instr_is_sra_instr_a0 && ! FETCH_Instr_is_or_instr_a0 && ! FETCH_Instr_is_and_instr_a0 && ! FETCH_Instr_is_csrrw_instr_a0 && ! FETCH_Instr_is_csrrs_instr_a0 && ! FETCH_Instr_is_csrrc_instr_a0 && ! FETCH_Instr_is_csrrwi_instr_a0 && ! FETCH_Instr_is_csrrsi_instr_a0 && ! FETCH_Instr_is_csrrci_instr_a0) ||
                                         (FETCH_Instr_raw_a0[1:0] != 2'b11); // All legal instructions have opcode[1:0] == 2'b11. We ignore these bits in decode logic.
                              assign FETCH_Instr_conditional_branch_a0 = FETCH_Instr_is_b_type_a0;
                           assign FETCH_Instr_jump_a0 = FETCH_Instr_is_jal_instr_a0;  // "Jump" in RISC-V means unconditional. (JALR is a separate redirect condition.)
                           assign FETCH_Instr_branch_a0 = FETCH_Instr_is_b_type_a0;
                           assign FETCH_Instr_indirect_jump_a0 = FETCH_Instr_is_jalr_instr_a0;
                           //_?$valid_decode
                              assign FETCH_Instr_ld_a0 = FETCH_Instr_raw_a0[6:3] == 4'b0;
                              assign FETCH_Instr_st_a0 = FETCH_Instr_is_s_type_a0;
                              assign FETCH_Instr_ld_st_a0 = FETCH_Instr_ld_a0 || FETCH_Instr_st_a0;
                              assign FETCH_Instr_ld_st_word_a0 = FETCH_Instr_ld_st_a0 && (FETCH_Instr_raw_funct3_a0[1] == 1'b1);
                              assign FETCH_Instr_ld_st_half_a0 = FETCH_Instr_ld_st_a0 && (FETCH_Instr_raw_funct3_a0[1:0] == 2'b01);
                              //$ld_st_byte = $ld_st && ($raw_funct3[1:0] == 2'b00);
                              `BOGUS_USE(FETCH_Instr_is___type_a0 FETCH_Instr_is_u_type_a0)
                        
                              // Output signals.
                              for (src = 1; src <= 2; src++) begin : L1_FETCH_Instr_Src //_/src

                                 // For $is_reg.
                                 logic L1_is_reg_a0;

                                 // For $reg.
                                 logic [4:0] L1_reg_a0;

                                 // Reg valid for this source, based on instruction type.
                                 assign L1_is_reg_a0 =
                                     
                                     (FETCH_Instr_is_r_type_a0 || FETCH_Instr_is_r4_type_a0 || (FETCH_Instr_is_i_type_a0 && (src == 1)) || FETCH_Instr_is_r2_type_a0 || FETCH_Instr_is_s_type_a0 || FETCH_Instr_is_b_type_a0);
                                 assign L1_reg_a0[4:0] = (src == 1) ? FETCH_Instr_raw_rs1_a0[4:0] : FETCH_Instr_raw_rs2_a0[4:0];
                              end
                        
                           // Condition signals must not themselves be conditioned (currently).
                           assign FETCH_Instr_dest_reg_a0[4:0] = FETCH_Instr_raw_rd_a0[4:0];   // int only
                           assign FETCH_Instr_dest_reg_valid_a0 =  FETCH_Instr_valid_decode_a0 && ! FETCH_Instr_is_s_type_a0 && ! FETCH_Instr_is_b_type_a0 &&
                                             | FETCH_Instr_dest_reg_a0;   // r0 not valid. Asserts for int dest only (see /fpu/$dest_reg_valid for FP).
                        
                           //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 2104 as: m5+ifelse(m5_get(EXT_F), 1,
                              
                           //_\end_source
                        
                           // Actually load.
                           assign FETCH_Instr_spec_ld_a0 = FETCH_Instr_valid_decode_a0 && FETCH_Instr_ld_a0;
                        
                           // CSR decode.
                           assign FETCH_Instr_is_csr_write_a0 = FETCH_Instr_is_csrrw_instr_a0 || FETCH_Instr_is_csrrwi_instr_a0;
                           assign FETCH_Instr_is_csr_set_a0   = FETCH_Instr_is_csrrs_instr_a0 || FETCH_Instr_is_csrrsi_instr_a0;
                           assign FETCH_Instr_is_csr_clear_a0 = FETCH_Instr_is_csrrc_instr_a0 || FETCH_Instr_is_csrrci_instr_a0;
                           assign FETCH_Instr_is_csr_instr_a0 = FETCH_Instr_is_csr_write_a0 ||
                                           FETCH_Instr_is_csr_set_a0   ||
                                           FETCH_Instr_is_csr_clear_a0;
                           assign FETCH_Instr_valid_csr_a0 = 1'b0 || FETCH_Instr_is_csr_cycle_a0 || FETCH_Instr_is_csr_cycleh_a0 || FETCH_Instr_is_csr_time_a0 || FETCH_Instr_is_csr_timeh_a0 || FETCH_Instr_is_csr_instret_a0 || FETCH_Instr_is_csr_instreth_a0;
                           assign FETCH_Instr_csr_trap_a0 = FETCH_Instr_is_csr_instr_a0 && ! FETCH_Instr_valid_csr_a0;
                        //_\end_source
                     // Instantiate the branch predictor.
                     //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 3427   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 3996 as: m5+call(⌈branch_pred_⌉m5_get(BRANCH_PRED))
                        //_@0
                           assign FETCH_Instr_pred_taken_a0 = 1'b0;
                     //_\end_source
            
                     //_@0
                        assign FETCH_Instr_non_pipelined_a0 = FETCH_Instr_div_mul_a0  ;
                        assign FETCH_Instr_would_second_issue_a0 = (FETCH_Instr_ld_a0 && 1'b1) || FETCH_Instr_non_pipelined_a0;
                        // Pending value to write to dest reg, 1 for instructions that will second-issue.
                        assign FETCH_Instr_reg_wr_pending_a0 = FETCH_Instr_would_second_issue_a0 && ! FETCH_Instr_second_issue_a0;
                        `BOGUS_USE(FETCH_Instr_reg_wr_pending_a0)  // Not used if no bypass and no pending.
            
                        // ======
                        // Reg Rd
                        // ======
            
                        // Obtain source register values and pending bit for source registers.
                        //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 4121   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 4010 as: m5+operands(/instr, , /src, 2:1)
                           // Obtain source register values and pending bit for int or fp source registers. Bypass up to 3
                           // stages.
                           // It is not necessary to bypass pending, as we could delay the replay, but we implement
                           // bypass for performance.
                           // Pending has an additional read for the dest register as we need to replay for write-after-write
                           // hazard as well as write-after-read. To replay for dest write with the same timing, we must also
                           // bypass the dest reg's pending bit.
                           // TODO: Huh. Should we be using $dest_reg below instead of $commit_dest_reg and $second_issue instead of $commit_second_issue?
                           //       It looks like the GoodPath terms are supposed to protect against bad-path bypass into instructions that could commit.
                           
                           
                           
                           for (src = 1; src <= 2; src++) begin : L1b_FETCH_Instr_Src //_/src

                              // For $is_reg_condition.
                              logic L1_is_reg_condition_a0;

                              // For $pending.
                              logic L1_pending_a0;

                              // For $reg_value.
                              logic [31:0] L1_reg_value_a0;

                              // For $rf_value.
                              logic [31:0] L1_rf_value_a0;

                              assign L1_is_reg_condition_a0 = L1_FETCH_Instr_Src[src].L1_is_reg_a0 && FETCH_Instr_valid_decode_a0;  // Note: $is_reg can be set for RISC-V sr0.
                              //_?$is_reg_condition
                                 assign L1_rf_value_a0[31:0] =
                                      FETCH_Instr_Regs_value_a0[L1_FETCH_Instr_Src[src].L1_reg_a0];
                                 /* verilator lint_off WIDTH */  // TODO: Disabling WIDTH to work around what we think is https://github.com/verilator/verilator/issues/1613, when --fmtPackAll is in use.
                                 assign {L1_reg_value_a0[31:0], L1_pending_a0} =
                                    (L1_FETCH_Instr_Src[src].L1_reg_a0 == 5'b0) ? {32'b0, 1'b0} :  // Read r0 as 0 (not pending).
                                    // Bypass stages. Both register and pending are bypassed.
                                    // Bypassed registers must be from instructions that are good-path as of this instruction or are 2nd issuing.
                                    
                                    
                                    
                                    {L1_rf_value_a0, FETCH_Instr_Regs_pending_a0[L1_FETCH_Instr_Src[src].L1_reg_a0]};
                                 /* verilator lint_on WIDTH */
                              // Replay if source register is pending.
                              assign FETCH_Instr_Src_replay_a0[src] = L1_is_reg_condition_a0 && L1_pending_a0;
                           end
                        
                           // Also replay for pending dest reg to keep writes in order. Bypass dest reg pending to support this.
                           assign FETCH_Instr_is_dest_condition_a0 = FETCH_Instr_dest_reg_valid_a0 && FETCH_Instr_valid_decode_a0;
                           //_?$is_dest_condition
                              assign FETCH_Instr_dest_pending_a0 =
                                 (FETCH_Instr_wr_reg_a0 == 5'b0) ? 1'b0 :  // Read r0 as 0 (not pending) for RISC-V int regs. Not actually necessary, but it cuts off read of non-existent rs0, which might be an issue for formal verif tools.
                                 // Bypass stages.
                                 
                                 
                                 
                                 FETCH_Instr_Regs_pending_a0[FETCH_Instr_wr_reg_a0];
                           // Combine replay conditions for pending source or dest registers.
                           assign FETCH_Instr_pending_replay_a0 = | FETCH_Instr_Src_replay_a0 || (FETCH_Instr_is_dest_condition_a0 && FETCH_Instr_dest_pending_a0);
                        //_\end_source
                        for (src = 1; src <= 2; src++) begin : L1c_FETCH_Instr_Src //_/src

                           // For $dummy.
                           logic L1_dummy_a0,
                                 L1_dummy_a1;

                           assign L1_dummy_a0 = 1'b0;  // Dummy signal to pull through $ANY expressions when not building verification harness (since SandPiper currently complains about empty $ANY).
                        end
            
                        //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 4014 as: m5+ifelse(m5_get(EXT_F), 1,
                           
                        //_\end_source
                        assign FETCH_Instr_replay_a0 = (FETCH_Instr_pending_replay_a0 );
            
                     // =======
                     // Execute
                     // =======
            
                     // Instantiate the program.
                     //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 2138   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 4031 as: m5+call(m5_get(isa)⌈_exe⌉, @m5_get(EXECUTE_STAGE), @m5_get(RESULT_STAGE))
                        // if M_EXT is enabled, this handles the stalling logic
                        
                     
                        // if F_EXT is enabled, this handles the stalling logic
                        
                     
                        // if B_EXT is enabled, this handles the stalling logic
                        
                     
                        
                        //_@0
                           //_?$valid_decode_branch
                              assign FETCH_Instr_branch_target_a0[31:0] = FETCH_Instr_Pc_a0[31:0] + FETCH_Instr_raw_b_imm_a0[31:0];
                              assign FETCH_Instr_misaligned_pc_a0 = | FETCH_Instr_raw_b_imm_a0[1:0];
                           //_?$jump  // (JAL, not JALR)
                              assign FETCH_Instr_jump_target_a0[31:0] = FETCH_Instr_Pc_a0[31:0] + FETCH_Instr_raw_j_imm_a0[31:0];
                              assign FETCH_Instr_misaligned_jump_target_a0 = FETCH_Instr_raw_j_imm_a0[1];
                        //_@0
                           // Execution.
                           assign FETCH_Instr_valid_exe_a0 = FETCH_Instr_valid_decode_a0; // Execute if we decoded.
                           //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 2159 as: m5+ifelse(m5_get(EXT_M), 1,
                              
                           //_\end_source
                     
                           //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 2198 as: m5+ifelse(m5_get(EXT_F), 1,
                              
                           //_\end_source
                     
                     
                           //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 2222 as: m5+ifelse(m5_get(EXT_B), 1,
                              
                           //_\end_source
                     
                           // hold_inst scope is not needed when long latency instructions are disabled
                           
                           // Compute results for each instruction, independent of decode (power-hungry, but fast).
                           //_?$valid_exe
                              assign FETCH_Instr_equal_a0 = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 == L1b_FETCH_Instr_Src[2].L1_reg_value_a0;
                           //_?$branch
                              assign FETCH_Instr_taken_a0 =
                                 FETCH_Instr_is_j_type_a0 ||
                                 (FETCH_Instr_is_beq_instr_a0 && FETCH_Instr_equal_a0) ||
                                 (FETCH_Instr_is_bne_instr_a0 && ! FETCH_Instr_equal_a0) ||
                                 ((FETCH_Instr_is_blt_instr_a0 || FETCH_Instr_is_bltu_instr_a0 || FETCH_Instr_is_bge_instr_a0 || FETCH_Instr_is_bgeu_instr_a0) &&
                                  ((FETCH_Instr_is_bge_instr_a0 || FETCH_Instr_is_bgeu_instr_a0) ^
                                   (({(FETCH_Instr_is_blt_instr_a0 ^ L1b_FETCH_Instr_Src[1].L1_reg_value_a0[31]), L1b_FETCH_Instr_Src[1].L1_reg_value_a0[31-1:0]} <
                                     {(FETCH_Instr_is_blt_instr_a0 ^ L1b_FETCH_Instr_Src[2].L1_reg_value_a0[31]), L1b_FETCH_Instr_Src[2].L1_reg_value_a0[31-1:0]}
                                    ) ^ ((L1b_FETCH_Instr_Src[1].L1_reg_value_a0[31] != L1b_FETCH_Instr_Src[2].L1_reg_value_a0[31]) & FETCH_Instr_is_bge_instr_a0)
                                   )
                                  )
                                 );
                           //_?$indirect_jump  // (JALR)
                              assign FETCH_Instr_indirect_jump_full_target_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 + FETCH_Instr_raw_i_imm_a0;
                              assign FETCH_Instr_indirect_jump_target_a0[31:0] = {FETCH_Instr_indirect_jump_full_target_a0[31:1], 1'b0};
                              assign FETCH_Instr_misaligned_indirect_jump_target_a0 = FETCH_Instr_indirect_jump_full_target_a0[1];
                           //_?$valid_exe
                              // Compute each individual instruction result, combined per-instruction by a macro.
                              // TODO: Could provide some macro magic to specify combined instructions w/ a single result and mux select.
                              //       This would reduce code below and probably improve implementation.
                     
                              assign FETCH_Instr_lui_rslt_a0[31:0]   = {FETCH_Instr_raw_u_imm_a0[31:12], 12'b0};
                              assign FETCH_Instr_auipc_rslt_a0[31:0] = FETCH_Instr_Pc_a0 + FETCH_Instr_raw_u_imm_a0;
                              assign FETCH_Instr_jal_rslt_a0[31:0]   = FETCH_Instr_Pc_a0 + 4;
                              assign FETCH_Instr_jalr_rslt_a0[31:0]  = FETCH_Instr_Pc_a0 + 4;
                              // Load instructions. If returning ld is enabled, load instructions write no meaningful result, so we use zeros.
                              //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 2335 as: m5+ifelse(m5_get(INJECT_RETURNING_LD), 1,
                                 //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 2336   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__22.
                                    assign FETCH_Instr_lb_rslt_a0[31:0]    = 32'b0;
                                    assign FETCH_Instr_lh_rslt_a0[31:0]    = 32'b0;
                                    assign FETCH_Instr_lw_rslt_a0[31:0]    = 32'b0;
                                    assign FETCH_Instr_lbu_rslt_a0[31:0]   = 32'b0;
                                    assign FETCH_Instr_lhu_rslt_a0[31:0]   = 32'b0;
                                    
                                    
                                    
                                 //_\end_source
                              //_\end_source
                              assign FETCH_Instr_addi_rslt_a0[31:0]  = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 + FETCH_Instr_raw_i_imm_a0;  // TODO: This has its own adder; could share w/ add/sub.
                              assign FETCH_Instr_xori_rslt_a0[31:0]  = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 ^ FETCH_Instr_raw_i_imm_a0;
                              assign FETCH_Instr_ori_rslt_a0[31:0]   = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 | FETCH_Instr_raw_i_imm_a0;
                              assign FETCH_Instr_andi_rslt_a0[31:0]  = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 & FETCH_Instr_raw_i_imm_a0;
                              assign FETCH_Instr_slli_rslt_a0[31:0]  = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 << FETCH_Instr_raw_i_imm_a0[5:0];
                              assign FETCH_Instr_srli_intermediate_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 >> FETCH_Instr_raw_i_imm_a0[5:0];
                              assign FETCH_Instr_srai_intermediate_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0[31] ? FETCH_Instr_srli_intermediate_rslt_a0 | ((32'b0 - 1) << (32 - FETCH_Instr_raw_i_imm_a0[5:0]) ): FETCH_Instr_srli_intermediate_rslt_a0;
                              assign FETCH_Instr_srl_rslt_a0[31:0]   = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 >> L1b_FETCH_Instr_Src[2].L1_reg_value_a0[4:0];
                              assign FETCH_Instr_sra_rslt_a0[31:0]   = L1b_FETCH_Instr_Src[1].L1_reg_value_a0[31] ? FETCH_Instr_srl_rslt_a0 | ((32'b0 - 1) << (32 - L1b_FETCH_Instr_Src[2].L1_reg_value_a0[4:0]) ): FETCH_Instr_srl_rslt_a0;
                              assign FETCH_Instr_slti_rslt_a0[31:0]  =  (L1b_FETCH_Instr_Src[1].L1_reg_value_a0[31] == FETCH_Instr_raw_i_imm_a0[31]) ? FETCH_Instr_sltiu_rslt_a0 : {31'b0,L1b_FETCH_Instr_Src[1].L1_reg_value_a0[31]};
                              assign FETCH_Instr_sltiu_rslt_a0[31:0] = (L1b_FETCH_Instr_Src[1].L1_reg_value_a0 < FETCH_Instr_raw_i_imm_a0) ? 1 : 0;
                              assign FETCH_Instr_srai_rslt_a0[31:0]  = FETCH_Instr_srai_intermediate_rslt_a0;
                              assign FETCH_Instr_srli_rslt_a0[31:0]  = FETCH_Instr_srli_intermediate_rslt_a0;
                              assign FETCH_Instr_add_sub_rslt_a0[31:0] = (FETCH_Instr_raw_funct7_a0[5] == 1) ?  L1b_FETCH_Instr_Src[1].L1_reg_value_a0 - L1b_FETCH_Instr_Src[2].L1_reg_value_a0 : L1b_FETCH_Instr_Src[1].L1_reg_value_a0 + L1b_FETCH_Instr_Src[2].L1_reg_value_a0;
                              assign FETCH_Instr_add_rslt_a0[31:0]   = FETCH_Instr_add_sub_rslt_a0;
                              assign FETCH_Instr_sub_rslt_a0[31:0]   = FETCH_Instr_add_sub_rslt_a0;
                              assign FETCH_Instr_sll_rslt_a0[31:0]   = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 << L1b_FETCH_Instr_Src[2].L1_reg_value_a0[4:0];
                              assign FETCH_Instr_slt_rslt_a0[31:0]   = (L1b_FETCH_Instr_Src[1].L1_reg_value_a0[31] == L1b_FETCH_Instr_Src[2].L1_reg_value_a0[31]) ? FETCH_Instr_sltu_rslt_a0 : {31'b0,L1b_FETCH_Instr_Src[1].L1_reg_value_a0[31]};
                              assign FETCH_Instr_sltu_rslt_a0[31:0]  = (L1b_FETCH_Instr_Src[1].L1_reg_value_a0 < L1b_FETCH_Instr_Src[2].L1_reg_value_a0) ? 1 : 0;
                              assign FETCH_Instr_xor_rslt_a0[31:0]   = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 ^ L1b_FETCH_Instr_Src[2].L1_reg_value_a0;
                              assign FETCH_Instr_or_rslt_a0[31:0]    = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 | L1b_FETCH_Instr_Src[2].L1_reg_value_a0;
                              assign FETCH_Instr_and_rslt_a0[31:0]   = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 & L1b_FETCH_Instr_Src[2].L1_reg_value_a0;
                              // CSR read instructions have the same result expression. Counting on synthesis to optimize result mux.
                              assign FETCH_Instr_csrrw_rslt_a0[31:0]  = FETCH_Instr_is_csr_instreth_a0 ? {{0{1'b0}}, FETCH_Instr_csr_instreth_a0} : FETCH_Instr_is_csr_instret_a0 ? {{0{1'b0}}, FETCH_Instr_csr_instret_a0} : FETCH_Instr_is_csr_timeh_a0 ? {{0{1'b0}}, FETCH_Instr_csr_timeh_a0} : FETCH_Instr_is_csr_time_a0 ? {{0{1'b0}}, FETCH_Instr_csr_time_a0} : FETCH_Instr_is_csr_cycleh_a0 ? {{0{1'b0}}, FETCH_Instr_csr_cycleh_a0} : FETCH_Instr_is_csr_cycle_a0 ? {{0{1'b0}}, FETCH_Instr_csr_cycle_a0} : 32'bx;
                              assign FETCH_Instr_csrrs_rslt_a0[31:0]  = FETCH_Instr_csrrw_rslt_a0;
                              assign FETCH_Instr_csrrc_rslt_a0[31:0]  = FETCH_Instr_csrrw_rslt_a0;
                              assign FETCH_Instr_csrrwi_rslt_a0[31:0] = FETCH_Instr_csrrw_rslt_a0;
                              assign FETCH_Instr_csrrsi_rslt_a0[31:0] = FETCH_Instr_csrrw_rslt_a0;
                              assign FETCH_Instr_csrrci_rslt_a0[31:0] = FETCH_Instr_csrrw_rslt_a0;
                     
                              // "M" Extension.
                     
                              //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 2388 as: m5+ifelse(m5_get(EXT_M), 1,
                                 
                              //_\end_source
                     
                              // "F" Extension.
                     
                              // TODO: Move this under /fpu.
                              //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 2409 as: m5+ifelse(m5_get(EXT_F), 1,
                                 
                              //_\end_source
                     
                              //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 2483 as: m5+ifelse(m5_get(EXT_B), 1,
                                 
                              //_\end_source
                     
                        // CSR logic
                        // ---------
                        //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1828   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 2607 as: m5+riscv_csrs(⌈⌉(m5_get(csrs))⌈⌉)
                        
                           
                           //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1783   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1831 as: m5+riscv_csr(m5__l(1831)m5_eval(m5__l(1831)m5_call(get,⌈csr_⌉m4_csr⌈_args⌉)))
                              //--------------
                              // CSR CYCLE
                              //--------------
                              //_@0
                                 assign FETCH_Instr_is_csr_cycle_a0 = FETCH_Instr_raw_a0[31:20] == 12'hC00;
                              //_@0
                                 // CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
                                 // Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
                                 
                           
                                 //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1794 as: m5+ifelse(1, 1,
                                    //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1795   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__27.
                                       // hw_wr_mask conditioned by hw_wr.
                                       assign FETCH_Instr_csr_cycle_hw_wr_en_mask_a0[31:0] = {32{FETCH_Instr_csr_cycle_hw_wr_a0}} & FETCH_Instr_csr_cycle_hw_wr_mask_a0;
                                       // The CSR value, updated by side-effect writes.
                                       assign FETCH_Instr_upd_csr_cycle_a0[31:0] =
                                            (FETCH_Instr_csr_cycle_hw_wr_en_mask_a0 & FETCH_Instr_csr_cycle_hw_wr_value_a0) | (~ FETCH_Instr_csr_cycle_hw_wr_en_mask_a0 & FETCH_Instr_csr_cycle_a0);
                                    //_\end_source
                                 //_\end_source
                                 //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1806 as: m5+ifelse(1, RO,
                                    //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1809   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__30.
                                       // Next value of the CSR.
                                       assign FETCH_Instr_csr_cycle_masked_wr_value_a0[31:0] =
                                            FETCH_Instr_csr_wr_value_a0[31:0] & {32{1'b1}};
                                       assign FETCH_Instr_csr_cycle_n1[31:0] =
                                            FETCH_Instr_reset_a0 ? 32'b0 :
                                            ! FETCH_Instr_commit_a0
                                                   ? FETCH_Instr_upd_csr_cycle_a0 :
                                            FETCH_Instr_is_csr_write_a0 && FETCH_Instr_is_csr_cycle_a0
                                                   ? FETCH_Instr_csr_cycle_masked_wr_value_a0 | (FETCH_Instr_upd_csr_cycle_a0 & ~ {32{1'b1}}) :
                                            FETCH_Instr_is_csr_set_a0   && FETCH_Instr_is_csr_cycle_a0
                                                   ? FETCH_Instr_upd_csr_cycle_a0 |   FETCH_Instr_csr_cycle_masked_wr_value_a0 :
                                            FETCH_Instr_is_csr_clear_a0 && FETCH_Instr_is_csr_cycle_a0
                                                   ? FETCH_Instr_upd_csr_cycle_a0 & ~ FETCH_Instr_csr_cycle_masked_wr_value_a0 :
                                            // No CSR instruction update, only h/w side-effects.
                                                     FETCH_Instr_upd_csr_cycle_a0;
                                    //_\end_source
                                 //_\end_source
                           //_\end_source
                           
                           //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1783   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1831 as: m5+riscv_csr(m5__l(1831)m5_eval(m5__l(1831)m5_call(get,⌈csr_⌉m4_csr⌈_args⌉)))
                              //--------------
                              // CSR CYCLEH
                              //--------------
                              //_@0
                                 assign FETCH_Instr_is_csr_cycleh_a0 = FETCH_Instr_raw_a0[31:20] == 12'hC80;
                              //_@0
                                 // CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
                                 // Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
                                 
                           
                                 //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1794 as: m5+ifelse(1, 1,
                                    //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1795   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__31.
                                       // hw_wr_mask conditioned by hw_wr.
                                       assign FETCH_Instr_csr_cycleh_hw_wr_en_mask_a0[31:0] = {32{FETCH_Instr_csr_cycleh_hw_wr_a0}} & FETCH_Instr_csr_cycleh_hw_wr_mask_a0;
                                       // The CSR value, updated by side-effect writes.
                                       assign FETCH_Instr_upd_csr_cycleh_a0[31:0] =
                                            (FETCH_Instr_csr_cycleh_hw_wr_en_mask_a0 & FETCH_Instr_csr_cycleh_hw_wr_value_a0) | (~ FETCH_Instr_csr_cycleh_hw_wr_en_mask_a0 & FETCH_Instr_csr_cycleh_a0);
                                    //_\end_source
                                 //_\end_source
                                 //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1806 as: m5+ifelse(1, RO,
                                    //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1809   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__34.
                                       // Next value of the CSR.
                                       assign FETCH_Instr_csr_cycleh_masked_wr_value_a0[31:0] =
                                            FETCH_Instr_csr_wr_value_a0[31:0] & {32{1'b1}};
                                       assign FETCH_Instr_csr_cycleh_n1[31:0] =
                                            FETCH_Instr_reset_a0 ? 32'b0 :
                                            ! FETCH_Instr_commit_a0
                                                   ? FETCH_Instr_upd_csr_cycleh_a0 :
                                            FETCH_Instr_is_csr_write_a0 && FETCH_Instr_is_csr_cycleh_a0
                                                   ? FETCH_Instr_csr_cycleh_masked_wr_value_a0 | (FETCH_Instr_upd_csr_cycleh_a0 & ~ {32{1'b1}}) :
                                            FETCH_Instr_is_csr_set_a0   && FETCH_Instr_is_csr_cycleh_a0
                                                   ? FETCH_Instr_upd_csr_cycleh_a0 |   FETCH_Instr_csr_cycleh_masked_wr_value_a0 :
                                            FETCH_Instr_is_csr_clear_a0 && FETCH_Instr_is_csr_cycleh_a0
                                                   ? FETCH_Instr_upd_csr_cycleh_a0 & ~ FETCH_Instr_csr_cycleh_masked_wr_value_a0 :
                                            // No CSR instruction update, only h/w side-effects.
                                                     FETCH_Instr_upd_csr_cycleh_a0;
                                    //_\end_source
                                 //_\end_source
                           //_\end_source
                           
                           //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1783   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1831 as: m5+riscv_csr(m5__l(1831)m5_eval(m5__l(1831)m5_call(get,⌈csr_⌉m4_csr⌈_args⌉)))
                              //--------------
                              // CSR TIME
                              //--------------
                              //_@0
                                 assign FETCH_Instr_is_csr_time_a0 = FETCH_Instr_raw_a0[31:20] == 12'hC01;
                              //_@0
                                 // CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
                                 // Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
                                 
                           
                                 //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1794 as: m5+ifelse(1, 1,
                                    //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1795   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__35.
                                       // hw_wr_mask conditioned by hw_wr.
                                       assign FETCH_Instr_csr_time_hw_wr_en_mask_a0[31:0] = {32{FETCH_Instr_csr_time_hw_wr_a0}} & FETCH_Instr_csr_time_hw_wr_mask_a0;
                                       // The CSR value, updated by side-effect writes.
                                       assign FETCH_Instr_upd_csr_time_a0[31:0] =
                                            (FETCH_Instr_csr_time_hw_wr_en_mask_a0 & FETCH_Instr_csr_time_hw_wr_value_a0) | (~ FETCH_Instr_csr_time_hw_wr_en_mask_a0 & FETCH_Instr_csr_time_a0);
                                    //_\end_source
                                 //_\end_source
                                 //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1806 as: m5+ifelse(1, RO,
                                    //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1809   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__38.
                                       // Next value of the CSR.
                                       assign FETCH_Instr_csr_time_masked_wr_value_a0[31:0] =
                                            FETCH_Instr_csr_wr_value_a0[31:0] & {32{1'b1}};
                                       assign FETCH_Instr_csr_time_n1[31:0] =
                                            FETCH_Instr_reset_a0 ? 32'b0 :
                                            ! FETCH_Instr_commit_a0
                                                   ? FETCH_Instr_upd_csr_time_a0 :
                                            FETCH_Instr_is_csr_write_a0 && FETCH_Instr_is_csr_time_a0
                                                   ? FETCH_Instr_csr_time_masked_wr_value_a0 | (FETCH_Instr_upd_csr_time_a0 & ~ {32{1'b1}}) :
                                            FETCH_Instr_is_csr_set_a0   && FETCH_Instr_is_csr_time_a0
                                                   ? FETCH_Instr_upd_csr_time_a0 |   FETCH_Instr_csr_time_masked_wr_value_a0 :
                                            FETCH_Instr_is_csr_clear_a0 && FETCH_Instr_is_csr_time_a0
                                                   ? FETCH_Instr_upd_csr_time_a0 & ~ FETCH_Instr_csr_time_masked_wr_value_a0 :
                                            // No CSR instruction update, only h/w side-effects.
                                                     FETCH_Instr_upd_csr_time_a0;
                                    //_\end_source
                                 //_\end_source
                           //_\end_source
                           
                           //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1783   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1831 as: m5+riscv_csr(m5__l(1831)m5_eval(m5__l(1831)m5_call(get,⌈csr_⌉m4_csr⌈_args⌉)))
                              //--------------
                              // CSR TIMEH
                              //--------------
                              //_@0
                                 assign FETCH_Instr_is_csr_timeh_a0 = FETCH_Instr_raw_a0[31:20] == 12'hC81;
                              //_@0
                                 // CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
                                 // Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
                                 
                           
                                 //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1794 as: m5+ifelse(1, 1,
                                    //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1795   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__39.
                                       // hw_wr_mask conditioned by hw_wr.
                                       assign FETCH_Instr_csr_timeh_hw_wr_en_mask_a0[31:0] = {32{FETCH_Instr_csr_timeh_hw_wr_a0}} & FETCH_Instr_csr_timeh_hw_wr_mask_a0;
                                       // The CSR value, updated by side-effect writes.
                                       assign FETCH_Instr_upd_csr_timeh_a0[31:0] =
                                            (FETCH_Instr_csr_timeh_hw_wr_en_mask_a0 & FETCH_Instr_csr_timeh_hw_wr_value_a0) | (~ FETCH_Instr_csr_timeh_hw_wr_en_mask_a0 & FETCH_Instr_csr_timeh_a0);
                                    //_\end_source
                                 //_\end_source
                                 //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1806 as: m5+ifelse(1, RO,
                                    //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1809   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__42.
                                       // Next value of the CSR.
                                       assign FETCH_Instr_csr_timeh_masked_wr_value_a0[31:0] =
                                            FETCH_Instr_csr_wr_value_a0[31:0] & {32{1'b1}};
                                       assign FETCH_Instr_csr_timeh_n1[31:0] =
                                            FETCH_Instr_reset_a0 ? 32'b0 :
                                            ! FETCH_Instr_commit_a0
                                                   ? FETCH_Instr_upd_csr_timeh_a0 :
                                            FETCH_Instr_is_csr_write_a0 && FETCH_Instr_is_csr_timeh_a0
                                                   ? FETCH_Instr_csr_timeh_masked_wr_value_a0 | (FETCH_Instr_upd_csr_timeh_a0 & ~ {32{1'b1}}) :
                                            FETCH_Instr_is_csr_set_a0   && FETCH_Instr_is_csr_timeh_a0
                                                   ? FETCH_Instr_upd_csr_timeh_a0 |   FETCH_Instr_csr_timeh_masked_wr_value_a0 :
                                            FETCH_Instr_is_csr_clear_a0 && FETCH_Instr_is_csr_timeh_a0
                                                   ? FETCH_Instr_upd_csr_timeh_a0 & ~ FETCH_Instr_csr_timeh_masked_wr_value_a0 :
                                            // No CSR instruction update, only h/w side-effects.
                                                     FETCH_Instr_upd_csr_timeh_a0;
                                    //_\end_source
                                 //_\end_source
                           //_\end_source
                           
                           //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1783   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1831 as: m5+riscv_csr(m5__l(1831)m5_eval(m5__l(1831)m5_call(get,⌈csr_⌉m4_csr⌈_args⌉)))
                              //--------------
                              // CSR INSTRET
                              //--------------
                              //_@0
                                 assign FETCH_Instr_is_csr_instret_a0 = FETCH_Instr_raw_a0[31:20] == 12'hC02;
                              //_@0
                                 // CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
                                 // Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
                                 
                           
                                 //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1794 as: m5+ifelse(1, 1,
                                    //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1795   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__43.
                                       // hw_wr_mask conditioned by hw_wr.
                                       assign FETCH_Instr_csr_instret_hw_wr_en_mask_a0[31:0] = {32{FETCH_Instr_csr_instret_hw_wr_a0}} & FETCH_Instr_csr_instret_hw_wr_mask_a0;
                                       // The CSR value, updated by side-effect writes.
                                       assign FETCH_Instr_upd_csr_instret_a0[31:0] =
                                            (FETCH_Instr_csr_instret_hw_wr_en_mask_a0 & FETCH_Instr_csr_instret_hw_wr_value_a0) | (~ FETCH_Instr_csr_instret_hw_wr_en_mask_a0 & FETCH_Instr_csr_instret_a0);
                                    //_\end_source
                                 //_\end_source
                                 //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1806 as: m5+ifelse(1, RO,
                                    //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1809   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__46.
                                       // Next value of the CSR.
                                       assign FETCH_Instr_csr_instret_masked_wr_value_a0[31:0] =
                                            FETCH_Instr_csr_wr_value_a0[31:0] & {32{1'b1}};
                                       assign FETCH_Instr_csr_instret_n1[31:0] =
                                            FETCH_Instr_reset_a0 ? 32'b0 :
                                            ! FETCH_Instr_commit_a0
                                                   ? FETCH_Instr_upd_csr_instret_a0 :
                                            FETCH_Instr_is_csr_write_a0 && FETCH_Instr_is_csr_instret_a0
                                                   ? FETCH_Instr_csr_instret_masked_wr_value_a0 | (FETCH_Instr_upd_csr_instret_a0 & ~ {32{1'b1}}) :
                                            FETCH_Instr_is_csr_set_a0   && FETCH_Instr_is_csr_instret_a0
                                                   ? FETCH_Instr_upd_csr_instret_a0 |   FETCH_Instr_csr_instret_masked_wr_value_a0 :
                                            FETCH_Instr_is_csr_clear_a0 && FETCH_Instr_is_csr_instret_a0
                                                   ? FETCH_Instr_upd_csr_instret_a0 & ~ FETCH_Instr_csr_instret_masked_wr_value_a0 :
                                            // No CSR instruction update, only h/w side-effects.
                                                     FETCH_Instr_upd_csr_instret_a0;
                                    //_\end_source
                                 //_\end_source
                           //_\end_source
                           
                           //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1783   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1831 as: m5+riscv_csr(m5__l(1831)m5_eval(m5__l(1831)m5_call(get,⌈csr_⌉m4_csr⌈_args⌉)))
                              //--------------
                              // CSR INSTRETH
                              //--------------
                              //_@0
                                 assign FETCH_Instr_is_csr_instreth_a0 = FETCH_Instr_raw_a0[31:20] == 12'hC82;
                              //_@0
                                 // CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
                                 // Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
                                 
                           
                                 //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1794 as: m5+ifelse(1, 1,
                                    //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1795   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__47.
                                       // hw_wr_mask conditioned by hw_wr.
                                       assign FETCH_Instr_csr_instreth_hw_wr_en_mask_a0[31:0] = {32{FETCH_Instr_csr_instreth_hw_wr_a0}} & FETCH_Instr_csr_instreth_hw_wr_mask_a0;
                                       // The CSR value, updated by side-effect writes.
                                       assign FETCH_Instr_upd_csr_instreth_a0[31:0] =
                                            (FETCH_Instr_csr_instreth_hw_wr_en_mask_a0 & FETCH_Instr_csr_instreth_hw_wr_value_a0) | (~ FETCH_Instr_csr_instreth_hw_wr_en_mask_a0 & FETCH_Instr_csr_instreth_a0);
                                    //_\end_source
                                 //_\end_source
                                 //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1806 as: m5+ifelse(1, RO,
                                    //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1809   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__50.
                                       // Next value of the CSR.
                                       assign FETCH_Instr_csr_instreth_masked_wr_value_a0[31:0] =
                                            FETCH_Instr_csr_wr_value_a0[31:0] & {32{1'b1}};
                                       assign FETCH_Instr_csr_instreth_n1[31:0] =
                                            FETCH_Instr_reset_a0 ? 32'b0 :
                                            ! FETCH_Instr_commit_a0
                                                   ? FETCH_Instr_upd_csr_instreth_a0 :
                                            FETCH_Instr_is_csr_write_a0 && FETCH_Instr_is_csr_instreth_a0
                                                   ? FETCH_Instr_csr_instreth_masked_wr_value_a0 | (FETCH_Instr_upd_csr_instreth_a0 & ~ {32{1'b1}}) :
                                            FETCH_Instr_is_csr_set_a0   && FETCH_Instr_is_csr_instreth_a0
                                                   ? FETCH_Instr_upd_csr_instreth_a0 |   FETCH_Instr_csr_instreth_masked_wr_value_a0 :
                                            FETCH_Instr_is_csr_clear_a0 && FETCH_Instr_is_csr_instreth_a0
                                                   ? FETCH_Instr_upd_csr_instreth_a0 & ~ FETCH_Instr_csr_instreth_masked_wr_value_a0 :
                                            // No CSR instruction update, only h/w side-effects.
                                                     FETCH_Instr_upd_csr_instreth_a0;
                                    //_\end_source
                                 //_\end_source
                           //_\end_source
                           
                        //_\end_source
                        //_@0
                           //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1834   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 2609 as: m5+riscv_csr_logic()
                              //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1835 as: m5+ifelse(m5_get(csrs), ⌈⌉, ⌈⌉,
                                 //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1836   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__51.
                                    // CSR write value for CSR write instructions.
                                    assign FETCH_Instr_csr_wr_value_a0[31:0] = FETCH_Instr_raw_funct3_a0[2] ? {27'b0, FETCH_Instr_raw_rs1_a0} : L1b_FETCH_Instr_Src[1].L1_reg_value_a0;
                                 //_\end_source
                              //_\end_source
                           
                              // Counter CSR
                              //
                              //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1843 as: m5+ifelse(m5__l(1843)m5_call(if_defined_as,NO_COUNTER_CSRS, 1, 1, 0), 1,
                                 //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1846   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__53.
                                    // Count within time unit. This is not reset on writes to time CSR, so time CSR is only accurate to time unit.
                                    assign FETCH_Instr_RemainingCyclesWithinTimeUnit_n1[30-1:0] =
                                         (FETCH_Instr_reset_a0 || FETCH_Instr_time_unit_expires_a0) ?
                                                30'd999999999 :
                                                FETCH_Instr_RemainingCyclesWithinTimeUnit_a0 - 30'b1;
                                    assign FETCH_Instr_time_unit_expires_a0 = !( | FETCH_Instr_RemainingCyclesWithinTimeUnit_a0);  // reaches zero
                                                            
                                    assign FETCH_Instr_full_csr_cycle_hw_wr_value_a0[63:0]   = {FETCH_Instr_csr_cycleh_a0,   FETCH_Instr_csr_cycle_a0  } + 64'b1;
                                    assign FETCH_Instr_full_csr_time_hw_wr_value_a0[63:0]    = {FETCH_Instr_csr_timeh_a0,    FETCH_Instr_csr_time_a0   } + 64'b1;
                                    assign FETCH_Instr_full_csr_instret_hw_wr_value_a0[63:0] = {FETCH_Instr_csr_instreth_a0, FETCH_Instr_csr_instret_a0} + 64'b1;
                                    //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1857 as: m5+ifelse(m5_get(EXT_F), 1,
                                       
                                    //_\end_source
                                    // CSR h/w side-effect write signals.
                                    assign FETCH_Instr_csr_cycle_hw_wr_a0 = 1'b1;
                                    assign FETCH_Instr_csr_cycle_hw_wr_mask_a0[31:0] = {32{1'b1}};
                                    assign FETCH_Instr_csr_cycle_hw_wr_value_a0[31:0] = FETCH_Instr_full_csr_cycle_hw_wr_value_a0[31:0];
                                    assign FETCH_Instr_csr_cycleh_hw_wr_a0 = 1'b1;
                                    assign FETCH_Instr_csr_cycleh_hw_wr_mask_a0[31:0] = {32{1'b1}};
                                    assign FETCH_Instr_csr_cycleh_hw_wr_value_a0[31:0] = FETCH_Instr_full_csr_cycle_hw_wr_value_a0[63:32];
                                    assign FETCH_Instr_csr_time_hw_wr_a0 = FETCH_Instr_time_unit_expires_a0;
                                    assign FETCH_Instr_csr_time_hw_wr_mask_a0[31:0] = {32{1'b1}};
                                    assign FETCH_Instr_csr_time_hw_wr_value_a0[31:0] = FETCH_Instr_full_csr_time_hw_wr_value_a0[31:0];
                                    assign FETCH_Instr_csr_timeh_hw_wr_a0 = FETCH_Instr_time_unit_expires_a0;
                                    assign FETCH_Instr_csr_timeh_hw_wr_mask_a0[31:0] = {32{1'b1}};
                                    assign FETCH_Instr_csr_timeh_hw_wr_value_a0[31:0] = FETCH_Instr_full_csr_time_hw_wr_value_a0[63:32];
                                    assign FETCH_Instr_csr_instret_hw_wr_a0 = FETCH_Instr_commit_a0;
                                    assign FETCH_Instr_csr_instret_hw_wr_mask_a0[31:0] = {32{1'b1}};
                                    assign FETCH_Instr_csr_instret_hw_wr_value_a0[31:0] = FETCH_Instr_full_csr_instret_hw_wr_value_a0[31:0];
                                    assign FETCH_Instr_csr_instreth_hw_wr_a0 = FETCH_Instr_commit_a0;
                                    assign FETCH_Instr_csr_instreth_hw_wr_mask_a0[31:0] = {32{1'b1}};
                                    assign FETCH_Instr_csr_instreth_hw_wr_value_a0[31:0] = FETCH_Instr_full_csr_instret_hw_wr_value_a0[63:32];
                                    //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1884 as: m5+ifelse(m5_get(EXT_F), 1,
                                       
                                    //_\end_source
                                 //_\end_source
                              //_\end_source
                           
                              // For multicore CSRs:
                              //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1901 as: m5+ifelse(m5__l(1901)m5_calc(m5_get(NUM_CORES) > 1), 1,
                                 
                              //_\end_source
                           //_\end_source
                     
                           // Memory redirects.
                           //_?$valid_exe
                              assign FETCH_Instr_unnatural_addr_trap_a0 = (FETCH_Instr_ld_st_word_a0 && (FETCH_Instr_addr_a0[1:0] != 2'b00)) || (FETCH_Instr_ld_st_half_a0 && FETCH_Instr_addr_a0[0]);
                     
                           // Memory inputs
                           assign FETCH_Instr_ld_st_cond_a0 = FETCH_Instr_ld_st_a0 && FETCH_Instr_valid_exe_a0;
                           //_?$ld_st_cond
                              assign FETCH_Instr_addr_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 + (FETCH_Instr_ld_a0 ? FETCH_Instr_raw_i_imm_a0 : FETCH_Instr_raw_s_imm_a0);
                     
                           // Hardware assumes natural alignment. Otherwise, trap, and handle in s/w (though no s/w provided).
                           assign FETCH_Instr_st_cond_a0 = FETCH_Instr_st_a0 && FETCH_Instr_valid_exe_a0;
                           //_?$st_cond
                              // Provide a value to store, naturally-aligned to memory, that will work regardless of the lower $addr bits.
                              assign FETCH_Instr_st_reg_value_a0[31:0] = 
                                                                       L1b_FETCH_Instr_Src[2].L1_reg_value_a0;
                              //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 3375   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 2626 as: m5+swizzle_4_store_bytes()
                                 assign FETCH_Instr_st_value_a0[31:0] =
                                      FETCH_Instr_ld_st_word_a0 ? FETCH_Instr_st_reg_value_a0 :            // word
                                      FETCH_Instr_ld_st_half_a0 ? {2{FETCH_Instr_st_reg_value_a0[15:0]}} : // half
                                                    {4{FETCH_Instr_st_reg_value_a0[7:0]}};   // byte
                                 assign FETCH_Instr_st_mask_a0[3:0] =
                                      FETCH_Instr_ld_st_word_a0 ? 4'hf :                     // word
                                      FETCH_Instr_ld_st_half_a0 ? (FETCH_Instr_addr_a0[1] ? 4'hc : 4'h3) : // half
                                                    (4'h1 << FETCH_Instr_addr_a0[1:0]);      // byte
                              //_\end_source
                           //_?$second_issue_ld
                              //_/orig_load_inst
                                 assign FETCH_Instr_OrigLoadInst_spec_ld_cond_a0 = FETCH_Instr_OrigLoadInst_spec_ld_a0;
                                 //_?$spec_ld_cond
                                    //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 3386   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 2631 as: m5+sign_extend_4_load_bytes(! $raw_funct3[2])
                                       // (Verilator didn't like indexing $ld_data by signal math, so we do these the long way.)
                                       assign FETCH_Instr_OrigLoadInst_sign_bit_a0 =
                                          (! FETCH_Instr_OrigLoadInst_raw_funct3_a0[2]) && (
                                             FETCH_Instr_OrigLoadInst_ld_st_word_a0 ? FETCH_Instr_OrigLoadInst_ld_data_a0[31] :
                                             FETCH_Instr_OrigLoadInst_ld_st_half_a0 ? (FETCH_Instr_OrigLoadInst_addr_a0[1] ? FETCH_Instr_OrigLoadInst_ld_data_a0[31] : FETCH_Instr_OrigLoadInst_ld_data_a0[15]) :
                                                           ((FETCH_Instr_OrigLoadInst_addr_a0[1:0] == 2'b00) ? FETCH_Instr_OrigLoadInst_ld_data_a0[7] :
                                                            (FETCH_Instr_OrigLoadInst_addr_a0[1:0] == 2'b01) ? FETCH_Instr_OrigLoadInst_ld_data_a0[15] :
                                                            (FETCH_Instr_OrigLoadInst_addr_a0[1:0] == 2'b10) ? FETCH_Instr_OrigLoadInst_ld_data_a0[23] :
                                                                                    FETCH_Instr_OrigLoadInst_ld_data_a0[31]
                                                           )
                                          );
                                       assign {FETCH_Instr_OrigLoadInst_ld_rslt_a0[31:0], FETCH_Instr_OrigLoadInst_ld_mask_a0[3:0]} =
                                            FETCH_Instr_OrigLoadInst_ld_st_word_a0 ? {FETCH_Instr_OrigLoadInst_ld_data_a0, 4'b1111} :
                                            FETCH_Instr_OrigLoadInst_ld_st_half_a0 ? {{16{FETCH_Instr_OrigLoadInst_sign_bit_a0}}, FETCH_Instr_OrigLoadInst_addr_a0[1] ? {FETCH_Instr_OrigLoadInst_ld_data_a0[31:16], 4'b1100} :
                                                                                       {FETCH_Instr_OrigLoadInst_ld_data_a0[15:0] , 4'b0011}} :
                                                          {{24{FETCH_Instr_OrigLoadInst_sign_bit_a0}}, (FETCH_Instr_OrigLoadInst_addr_a0[1:0] == 2'b00) ? {FETCH_Instr_OrigLoadInst_ld_data_a0[7:0]  , 4'b0001} :
                                                                            (FETCH_Instr_OrigLoadInst_addr_a0[1:0] == 2'b01) ? {FETCH_Instr_OrigLoadInst_ld_data_a0[15:8] , 4'b0010} :
                                                                            (FETCH_Instr_OrigLoadInst_addr_a0[1:0] == 2'b10) ? {FETCH_Instr_OrigLoadInst_ld_data_a0[23:16], 4'b0100} :
                                                                                                    {FETCH_Instr_OrigLoadInst_ld_data_a0[31:24], 4'b1000}};
                                       `BOGUS_USE(FETCH_Instr_OrigLoadInst_ld_mask_a0) // It's only for RISC-V formal verification.
                                    //_\end_source
                     
                           // ISA-specific trap conditions:
                           // I can't see in the spec which of these is to commit results. I've made choices that make riscv-formal happy.
                           assign FETCH_Instr_non_aborting_isa_trap_a0 = 1'b0;
                           assign FETCH_Instr_aborting_isa_trap_a0 =     (FETCH_Instr_branch_a0 && FETCH_Instr_taken_a0 && FETCH_Instr_misaligned_pc_a0) ||
                                                    (FETCH_Instr_jump_a0 && FETCH_Instr_misaligned_jump_target_a0) ||
                                                    (FETCH_Instr_indirect_jump_a0 && FETCH_Instr_misaligned_indirect_jump_target_a0) ||
                                                    (FETCH_Instr_ld_st_a0 && FETCH_Instr_unnatural_addr_trap_a0) ||
                                                    FETCH_Instr_csr_trap_a0;
                     
                        //_@0
                           // Mux the correct result.
                           //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1924   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 2644 as: m5+riscv_rslt_mux_expr()
                              // The result mux, producing $rslt.
                              // The bulk of the mux is constructed from instruction characterization macros.
                              // The difficult cases are second-issue instructions.
                           
                              // in the case of second isssue for multiplication with ALTOPS enabled (or running formal checks for M extension),
                              // the module gives out the result in two cycles but we wait the full latency since it is held anyway.
                           
                              //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 1932 as: m5+ifelse(m5_get(ANY_NON_PIPELINED_INSTRS), 1,
                                 
                              //_\end_source
                           
                              assign FETCH_Instr_rslt_a0[31:0] =
                                    FETCH_Instr_second_issue_ld_a0 ? FETCH_Instr_OrigLoadInst_ld_rslt_a0 :
                                    
                                    32'b0 |
                                  ({32{FETCH_Instr_is_lui_instr_a0}} & FETCH_Instr_lui_rslt_a0) |
                                  ({32{FETCH_Instr_is_auipc_instr_a0}} & FETCH_Instr_auipc_rslt_a0) |
                                  ({32{FETCH_Instr_is_jal_instr_a0}} & FETCH_Instr_jal_rslt_a0) |
                                  ({32{FETCH_Instr_is_jalr_instr_a0}} & FETCH_Instr_jalr_rslt_a0) |
                                  ({32{FETCH_Instr_is_lb_instr_a0}} & FETCH_Instr_lb_rslt_a0) |
                                  ({32{FETCH_Instr_is_lh_instr_a0}} & FETCH_Instr_lh_rslt_a0) |
                                  ({32{FETCH_Instr_is_lw_instr_a0}} & FETCH_Instr_lw_rslt_a0) |
                                  ({32{FETCH_Instr_is_lbu_instr_a0}} & FETCH_Instr_lbu_rslt_a0) |
                                  ({32{FETCH_Instr_is_lhu_instr_a0}} & FETCH_Instr_lhu_rslt_a0) |
                                  ({32{FETCH_Instr_is_addi_instr_a0}} & FETCH_Instr_addi_rslt_a0) |
                                  ({32{FETCH_Instr_is_slti_instr_a0}} & FETCH_Instr_slti_rslt_a0) |
                                  ({32{FETCH_Instr_is_sltiu_instr_a0}} & FETCH_Instr_sltiu_rslt_a0) |
                                  ({32{FETCH_Instr_is_xori_instr_a0}} & FETCH_Instr_xori_rslt_a0) |
                                  ({32{FETCH_Instr_is_ori_instr_a0}} & FETCH_Instr_ori_rslt_a0) |
                                  ({32{FETCH_Instr_is_andi_instr_a0}} & FETCH_Instr_andi_rslt_a0) |
                                  ({32{FETCH_Instr_is_slli_instr_a0}} & FETCH_Instr_slli_rslt_a0) |
                                  ({32{FETCH_Instr_is_srli_instr_a0}} & FETCH_Instr_srli_rslt_a0) |
                                  ({32{FETCH_Instr_is_srai_instr_a0}} & FETCH_Instr_srai_rslt_a0) |
                                  ({32{FETCH_Instr_is_add_instr_a0}} & FETCH_Instr_add_rslt_a0) |
                                  ({32{FETCH_Instr_is_sub_instr_a0}} & FETCH_Instr_sub_rslt_a0) |
                                  ({32{FETCH_Instr_is_sll_instr_a0}} & FETCH_Instr_sll_rslt_a0) |
                                  ({32{FETCH_Instr_is_slt_instr_a0}} & FETCH_Instr_slt_rslt_a0) |
                                  ({32{FETCH_Instr_is_sltu_instr_a0}} & FETCH_Instr_sltu_rslt_a0) |
                                  ({32{FETCH_Instr_is_xor_instr_a0}} & FETCH_Instr_xor_rslt_a0) |
                                  ({32{FETCH_Instr_is_srl_instr_a0}} & FETCH_Instr_srl_rslt_a0) |
                                  ({32{FETCH_Instr_is_sra_instr_a0}} & FETCH_Instr_sra_rslt_a0) |
                                  ({32{FETCH_Instr_is_or_instr_a0}} & FETCH_Instr_or_rslt_a0) |
                                  ({32{FETCH_Instr_is_and_instr_a0}} & FETCH_Instr_and_rslt_a0) |
                                  ({32{FETCH_Instr_is_csrrw_instr_a0}} & FETCH_Instr_csrrw_rslt_a0) |
                                  ({32{FETCH_Instr_is_csrrs_instr_a0}} & FETCH_Instr_csrrs_rslt_a0) |
                                  ({32{FETCH_Instr_is_csrrc_instr_a0}} & FETCH_Instr_csrrc_rslt_a0) |
                                  ({32{FETCH_Instr_is_csrrwi_instr_a0}} & FETCH_Instr_csrrwi_rslt_a0) |
                                  ({32{FETCH_Instr_is_csrrsi_instr_a0}} & FETCH_Instr_csrrsi_rslt_a0) |
                                  ({32{FETCH_Instr_is_csrrci_instr_a0}} & FETCH_Instr_csrrci_rslt_a0);
                           //_\end_source
                     //_\end_source
            
                     //_@0
                        
                     //_@0
            
                        // =======
                        // Control
                        // =======
            
                        // A version of PC we can pull through $ANYs.
                        assign FETCH_Instr_pc_a0[31:0] = FETCH_Instr_Pc_a0[31:0];
                        `BOGUS_USE(FETCH_Instr_pc_a0)
            
            
                        // Execute stage redirect conditions.
                        assign FETCH_Instr_replay_trap_a0 = 1'b0;
                        assign FETCH_Instr_aborting_trap_a0 = (FETCH_Instr_replay_trap_a0 || (FETCH_Instr_valid_decode_a0 && FETCH_Instr_illegal_a0) || FETCH_Instr_aborting_isa_trap_a0);
                        assign FETCH_Instr_non_aborting_trap_a0 = FETCH_Instr_non_aborting_isa_trap_a0;
                        assign FETCH_Instr_mispred_branch_a0 = FETCH_Instr_branch_a0 && ! (FETCH_Instr_conditional_branch_a0 && (FETCH_Instr_taken_a0 == FETCH_Instr_pred_taken_a0));
                        //_?$valid_decode_branch
                           assign FETCH_Instr_branch_redir_pc_a0[31:0] =
                              // If fallthrough predictor, branch mispred always redirects taken, otherwise PC+1 for not-taken.
                              
                              FETCH_Instr_branch_target_a0;
            
                        assign FETCH_Instr_trap_target_a0[31:0] = FETCH_Instr_replay_trap_a0 ? FETCH_Instr_Pc_a0 : {{30{1'b1}}, 2'b0};  // TODO: What should this be? Using ones to terminate test for now.
            
                        // Determine whether the instruction should commit it's result.
                        //
                        // Abort: Instruction triggers a condition causing a no-commit.
                        // Commit: Ultimate decision to commit results of this instruction, considering aborts and
                        //         prior-instruction redirects (good-path)
                        //
                        // Treatment of loads:
                        //    Loads will commit. They write a garbage value and "pending" to the register file.
                        //    Returning loads clobber an instruction. This instruction is $abort'ed (as is the
                        //    returning load, since they are one in the same). Returning load must explicitly
                        //    write results.
                        //
            
                        assign FETCH_Instr_abort_a0 = 1'b0 || FETCH_Instr_no_fetch_a0 || FETCH_Instr_second_issue_a0 || FETCH_Instr_replay_a0 || FETCH_Instr_aborting_trap_a0;  // Note that abort conditions must also redirect to avoid forwarding
                                                  // their dest reg into subsequent good-path instructions.
            
                        // instruction's redirects. However, to meet timing, we consider this instruction separately, so,
                        // commit if valid as of the latest redirect from prior instructions and not abort of this instruction.
                        
                        // Normal case:
                        assign FETCH_Instr_good_path_a0 = (! FETCH_Instr_reset_a0 && FETCH_Instr_next_good_path_mask_a0[1]);
                        assign FETCH_Instr_commit_a0 = FETCH_Instr_good_path_a0 && ! FETCH_Instr_abort_a0;
                        
                        
                        
                        
                        
            
                        // Conditions that commit results.
                        assign FETCH_Instr_commit_dest_reg_a0 = (FETCH_Instr_dest_reg_valid_a0 && FETCH_Instr_commit_a0) || (FETCH_Instr_commit_second_issue_a0  );
            
                        
                        
                           
                        
                        assign FETCH_Instr_valid_ld_a0 = FETCH_Instr_ld_a0 && FETCH_Instr_commit_a0;
                        assign FETCH_Instr_valid_st_a0 = FETCH_Instr_st_a0 && FETCH_Instr_commit_a0;
            
               //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 3160   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 4097 as: m5+dmem(/top)
                  // This macro assumes little-endian.
                  
               
                  
                  /* DMEM_STYLE: ARRAY */
                  //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 3166 as: m5+ifelse(m5_get(UETRV_PCORE), 1,
                     //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ifelse.
                        //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ifelse.
                           //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ifelse.
                              //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 3229   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__62.
                                 //_|fetch
                                    //_/instr
                                       //_@0
                                          // A simple array memory with fixed or RANDOM latency.
                                          // The memory is placed in the fetch pipeline.
                                          // Required for VIZ.
                                          for (bank = 0; bank <= 3; bank++) begin : L1_FETCH_Instr_Bank //_/bank

                                             // For $addr.
                                             logic [31:0] L1_addr_a0;

                                             // For $ld_data.
                                             logic [(32 / 4) - 1 : 0] L1_ld_data_a0;

                                             // For $spec_ld.
                                             logic L1_spec_ld_a0;

                                             // For $st_mask.
                                             logic [3:0] L1_st_mask_a0;

                                             // For $st_value.
                                             logic [31:0] L1_st_value_a0;

                                             // For $valid_st.
                                             logic L1_valid_st_a0;

                                             assign {L1_addr_a0[31:0], L1_spec_ld_a0, L1_st_mask_a0[3:0], L1_st_value_a0[31:0], L1_valid_st_a0} = {FETCH_Instr_addr_a0, FETCH_Instr_spec_ld_a0, FETCH_Instr_st_mask_a0, FETCH_Instr_st_value_a0, FETCH_Instr_valid_st_a0}; // Find signal from outside of /bank.
                                             //_/mem
                                             //_?$spec_ld
                                                assign L1_ld_data_a0[(32 / 4) - 1 : 0] = L1b_FETCH_Instr_Bank[bank].L1_Mem_Value_a0[L1_addr_a0[4 + 2 : 2]];
                                          end
                                          // Simple ARRAY memory.
                                          // Combine $ld_data per bank, assuming little-endian.
                                          //$ld_data[31:0] = /bank[*]$ld_data;
                                          // Unfortunately formal verification tools can't handle multiple packed dimensions produced by the expression above, so we
                                          // build the concatination.
                                          assign FETCH_Instr_ld_data_a0[31:0] = {L1_FETCH_Instr_Bank[3].L1_ld_data_a0, L1_FETCH_Instr_Bank[2].L1_ld_data_a0, L1_FETCH_Instr_Bank[1].L1_ld_data_a0, L1_FETCH_Instr_Bank[0].L1_ld_data_a0};
                                             
                                          // =====
                                          // Store
                                          // =====
                                             
                                          // Array writes are not currently permitted to use assignment
                                          // syntax, so \always_comb is used, and this must be outside of
                                          // when conditions, so we need to use if. <<1 because no <= support
                                          // in this context. (This limitation will be lifted.)
                                          for (bank = 0; bank <= 3; bank++) begin : L1b_FETCH_Instr_Bank //_/bank

                                             // For /mem$Value.
                                             logic [(32 / 4) - 1 : 0] L1_Mem_Value_a0 [31:0];

                                             /*SV_plus*/
                                                always @ (posedge clk) begin
                                                   if (L1_FETCH_Instr_Bank[bank].L1_valid_st_a0 && L1_FETCH_Instr_Bank[bank].L1_st_mask_a0[bank])
                                                      L1_Mem_Value_a0[L1_FETCH_Instr_Bank[bank].L1_addr_a0[4 + 2 : 2]][(32 / 4) - 1 : 0] <= L1_FETCH_Instr_Bank[bank].L1_st_value_a0[(bank + 1) * (32 / 4) - 1: bank * (32 / 4)];
                                                end
                                          end
                                 //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 3262 as: m5+ifelse(m5_get(DMEM_STYLE), ARRAY,
                                    //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 3263   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__63.
                                       // Hmmm... nothing more to do for ARRAY memory.
                                    //_\end_source
                                 //_\end_source
                              //_\end_source
                           //_\end_source
                        //_\end_source
                     //_\end_source
                  //_\end_source
                  //_|fetch
                     //_/instr
                        //_@0
                           // A returning load clobbers the instruction. Done here with fixed latency.
                           // (Could do this with lower latency. Right now it goes through memory pipeline $ANY, and
                           //  it is non-speculative. Both could easily be fixed.)
                           assign FETCH_Instr_second_issue_ld_a0 = ! FETCH_Instr_reset_a0 && FETCH_Instr_valid_ld_a1 && 1'b1;
                        //_@0
                           // This reduces significantly once $ANY acts on subscope.
                           //_?$second_issue_ld
                              // This scope holds the original load for a returning load.
                              //_/orig_load_inst
                                 assign {FETCH_Instr_OrigLoadInst_addr_a0[1:0], FETCH_Instr_OrigLoadInst_dest_reg_a0[4:0], FETCH_Instr_OrigLoadInst_ld_data_a0[31:0], FETCH_Instr_OrigLoadInst_ld_st_half_a0, FETCH_Instr_OrigLoadInst_ld_st_word_a0, FETCH_Instr_OrigLoadInst_pc_a0[31:0], FETCH_Instr_OrigLoadInst_raw_funct3_a0[2], FETCH_Instr_OrigLoadInst_spec_ld_a0} = {FETCH_Instr_addr_a1[1:0], FETCH_Instr_dest_reg_a1, FETCH_Instr_ld_data_a1, FETCH_Instr_ld_st_half_a1, FETCH_Instr_ld_st_word_a1, FETCH_Instr_pc_a1, FETCH_Instr_raw_funct3_a1[2], FETCH_Instr_spec_ld_a1};
                                 for (src = 1; src <= 2; src++) begin : L1_FETCH_Instr_OrigLoadInst_Src //_/src

                                    // For $dummy.
                                    logic L1_dummy_a0;

                                    assign {L1_dummy_a0} = {L1c_FETCH_Instr_Src[src].L1_dummy_a1};
                                 end
                                 //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 3364 as: m5+ifelse(m5_get(EXT_F), 1,
                                    
                                 //_\end_source
               //_\end_source
               //_|fetch
                  //_/instr
                     // =========
                     // Reg Write
                     // =========
                     //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 4173   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 4103 as: m5+rf_wr(/instr, m5_get(REGS_RANGE), /instr$commit_dest_reg, /instr$dest_reg, /instr$rslt, /instr$reg_wr_pending, )
                        /* verilator lint_save */
                        /* verilator lint_on WIDTH */
                        //_@0
                           assign FETCH_Instr_wr_reg_a0[4:0] = FETCH_Instr_second_issue_a0 ? FETCH_Instr_OrigInst_dest_reg_a0 : FETCH_Instr_dest_reg_a0;
                        //_@0
                           //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 4179 as: m5+ifelse(m5_get(RF_STYLE), STUBBED,
                              //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 4184   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__67.
                                 // Reg Write (Floating Point Register)
                                 /*SV_plus*/
                                    always @ (posedge clk) begin
                                       if (FETCH_Instr_commit_dest_reg_a0)
                                          FETCH_Instr_Regs_value_a0[FETCH_Instr_wr_reg_a0][31:0] <= FETCH_Instr_rslt_a0;
                                    end
                              //_\end_source
                           //_\end_source
                           //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 4192 as: m5+ifelse(m5_get(PENDING_ENABLED), 1,
                              //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 4193   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__68.
                                 // Write $pending along with $value, but coded differently because it must be reset.
                                 for (regs = 1; regs <= 31; regs++) begin : L1_FETCH_Instr_Regs //_/regs
                                    assign FETCH_Instr_Regs_pending_n1[regs] = ! FETCH_Instr_reset_a0 && (((regs == FETCH_Instr_wr_reg_a0) && FETCH_Instr_commit_dest_reg_a0) ? FETCH_Instr_reg_wr_pending_a0 : FETCH_Instr_Regs_pending_a0[regs]);
                                 end
                              //_\end_source
                           //_\end_source
                        /* verilator lint_restore */
                     //_\end_source
            
                     // ======
                     // FPU RF
                     // ======
                     //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 4108 as: m5+ifelse(m5_get(EXT_F), 1,
                        
                     //_\end_source
            
                     //_@0
                        `BOGUS_USE(L1_FETCH_Instr_OrigInst_Src[2].L1_dummy_a0) // To pull $dummy through $ANY expressions, avoiding empty expressions.
            
                     // TODO. Seperate the $rslt and $reg_wr_pending committed to both "int" and "fpu" regs.
            //_\end_source
            
            
            
            
            
            
            
            
            //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 5675   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 6399 as: m5+cpu_viz.
               /* CPU_VIZ HERE */
               
               
               
               //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 4660   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 5680 as: m5+call(m5_get(isa)⌈_viz_logic⌉)
                  // Code that supports
                  //_|fetch
                     //_@0
                        //_/instr
                           // A type-independent immediate value, for debug. (For R-type, funct7 is used as immediate).
                           assign FETCH_Instr_imm_value_a0[31:0] =
                                ({32{FETCH_Instr_is_i_type_a0}} & FETCH_Instr_raw_i_imm_a0) |
                                ({32{FETCH_Instr_is_r_type_a0}} & {25'b0, FETCH_Instr_raw_funct7_a0}) |
                                ({32{FETCH_Instr_is_s_type_a0}} & FETCH_Instr_raw_s_imm_a0) |
                                ({32{FETCH_Instr_is_b_type_a0}} & FETCH_Instr_raw_b_imm_a0) |
                                ({32{FETCH_Instr_is_u_type_a0}} & FETCH_Instr_raw_u_imm_a0) |
                                ({32{FETCH_Instr_is_j_type_a0}} & FETCH_Instr_raw_j_imm_a0);
                           assign FETCH_Instr_imm_valid_a0 = FETCH_Instr_is_i_type_a0 || FETCH_Instr_is_r_type_a0 || FETCH_Instr_is_s_type_a0 || FETCH_Instr_is_b_type_a0 || FETCH_Instr_is_u_type_a0 || FETCH_Instr_is_j_type_a0;
               //_\end_source
               //_|fetch
                  //_@0
                     //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 5665   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 5683 as: m5+layout_viz(⌈left: 0, top: 0, width: 451, height: 251⌉, "#7AD7F0")
                        
                     //_\end_source
            
                     //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 4678   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 5685 as: m5+instruction_in_memory.
                        for (instr_mem = 0; instr_mem <= 13; instr_mem++) begin : L1b_FETCH_InstrMem //_/instr_mem
                           
                        end
                               
                     //_\end_source
            
                     //_/instr
                        //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 5201   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 5688 as: m5+instruction(⌈left: 10, top: 0⌉)
                           //_?$valid_decode
                              // For debug.
                              assign FETCH_Instr_mnemonic_a0[10*8-1:0] = FETCH_Instr_is_lui_instr_a0 ? "LUI       " : FETCH_Instr_is_auipc_instr_a0 ? "AUIPC     " : FETCH_Instr_is_jal_instr_a0 ? "JAL       " : FETCH_Instr_is_jalr_instr_a0 ? "JALR      " : FETCH_Instr_is_beq_instr_a0 ? "BEQ       " : FETCH_Instr_is_bne_instr_a0 ? "BNE       " : FETCH_Instr_is_blt_instr_a0 ? "BLT       " : FETCH_Instr_is_bge_instr_a0 ? "BGE       " : FETCH_Instr_is_bltu_instr_a0 ? "BLTU      " : FETCH_Instr_is_bgeu_instr_a0 ? "BGEU      " : FETCH_Instr_is_lb_instr_a0 ? "LB        " : FETCH_Instr_is_lh_instr_a0 ? "LH        " : FETCH_Instr_is_lw_instr_a0 ? "LW        " : FETCH_Instr_is_lbu_instr_a0 ? "LBU       " : FETCH_Instr_is_lhu_instr_a0 ? "LHU       " : FETCH_Instr_is_sb_instr_a0 ? "SB        " : FETCH_Instr_is_sh_instr_a0 ? "SH        " : FETCH_Instr_is_sw_instr_a0 ? "SW        " : FETCH_Instr_is_addi_instr_a0 ? "ADDI      " : FETCH_Instr_is_slti_instr_a0 ? "SLTI      " : FETCH_Instr_is_sltiu_instr_a0 ? "SLTIU     " : FETCH_Instr_is_xori_instr_a0 ? "XORI      " : FETCH_Instr_is_ori_instr_a0 ? "ORI       " : FETCH_Instr_is_andi_instr_a0 ? "ANDI      " : FETCH_Instr_is_slli_instr_a0 ? "SLLI      " : FETCH_Instr_is_srli_instr_a0 ? "SRLI      " : FETCH_Instr_is_srai_instr_a0 ? "SRAI      " : FETCH_Instr_is_add_instr_a0 ? "ADD       " : FETCH_Instr_is_sub_instr_a0 ? "SUB       " : FETCH_Instr_is_sll_instr_a0 ? "SLL       " : FETCH_Instr_is_slt_instr_a0 ? "SLT       " : FETCH_Instr_is_sltu_instr_a0 ? "SLTU      " : FETCH_Instr_is_xor_instr_a0 ? "XOR       " : FETCH_Instr_is_srl_instr_a0 ? "SRL       " : FETCH_Instr_is_sra_instr_a0 ? "SRA       " : FETCH_Instr_is_or_instr_a0 ? "OR        " : FETCH_Instr_is_and_instr_a0 ? "AND       " : FETCH_Instr_is_csrrw_instr_a0 ? "CSRRW     " : FETCH_Instr_is_csrrs_instr_a0 ? "CSRRS     " : FETCH_Instr_is_csrrc_instr_a0 ? "CSRRC     " : FETCH_Instr_is_csrrwi_instr_a0 ? "CSRRWI    " : FETCH_Instr_is_csrrsi_instr_a0 ? "CSRRSI    " : FETCH_Instr_is_csrrci_instr_a0 ? "CSRRCI    " :  "ILLEGAL   ";
                              `BOGUS_USE(FETCH_Instr_mnemonic_a0)
                           
                        //_\end_source
                        //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 4777   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 5689 as: m5+registers(/instr, int, Int RF, , 2, ⌈left: 350 + 605, top: 10⌉)
                           // /regs or /fpu_regs
                           for (src = 1; src <= 2; src++) begin : L1d_FETCH_Instr_Src //_/src
                              // There is an issue (#406) with \viz code indexing causing signals to be packed, and if a packed value
                              // has different fields on different clocks, Verilator throws warnings.
                              // These are unconditioned versions of the problematic signals.
                              assign FETCH_Instr_Src_unconditioned_reg_a0[src][4:0] = L1_FETCH_Instr_Src[src].L1_reg_a0;
                              assign FETCH_Instr_Src_unconditioned_is_reg_a0[src] = L1_FETCH_Instr_Src[src].L1_is_reg_a0;
                              assign FETCH_Instr_Src_unconditioned_reg_value_a0[src][31:0] = L1b_FETCH_Instr_Src[src].L1_reg_value_a0;
                           end
                           
                           for (regs = 1; regs <= 31; regs++) begin : L1b_FETCH_Instr_Regs //_/regs
                              
                           end
                        //_\end_source
                        //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 5172   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 5690 as: m5+register_csr(/regcsr, ⌈left: 103 + 605, top: 190⌉)
                           //_/regcsr
                              
                        //_\end_source
                        //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 4864   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 5691 as: m5+pipeline_control_viz(/pipe_ctrl, ⌈left: 103 + 605, top: 265 + 18 * m5_get(num_csrs), width: 220, height: 330⌉)
                           assign FETCH_Instr_first_issue_a0 = FETCH_Instr_commit_a0 && FETCH_Instr_would_second_issue_a0;
                           //_/pipe_ctrl
                              
                              //_/logic_diagram
                                 
                              //_/waterfall
                                 
                                 for (pipe_ctrl_instr = 0; pipe_ctrl_instr <= 2; pipe_ctrl_instr++) begin : L1_FETCH_Instr_PipeCtrl_Waterfall_PipeCtrlInstr //_/pipe_ctrl_instr  // Zero on the bottom. See this.getInstrIndex().
                                    
                                    for (pipe_ctrl_stage = 0; pipe_ctrl_stage <= 1; pipe_ctrl_stage++) begin : L2_PipeCtrlStage //_/pipe_ctrl_stage
                                       
                                    end
                                 end
                        //_\end_source
                        //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 5692 as: m5+ifelse(m5_get(EXT_F), 1,
                           
                        //_\end_source
                        //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 5530   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 5697 as: m5+memory_viz(/bank[m5__l(5697)m5_calc(m5_get(ADDRS_PER_WORD)-1):0] , /mem[m5_get(DATA_MEM_WORDS_RANGE)], ⌈left: 10 + (550 + 605) -10 + m5__l(5697)m5_call(if,m5_get(EXT_F), ⌈m5_get(VIZ_MEM_LEFT_ADJUST)⌉, 0), top: 10⌉)
                           //_\source /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 5531 as: m5+ifelse(m5__l(5531)m5_calc(m5__l(5531)m5_eq(m5_get(DMEM_STYLE), ARRAY) || m5__l(5531)m5_eq(m5_get(DMEM_STYLE), RANDOM)), 1,
                              //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 5532   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/3543cfd9d7ef9ae3b1e5750614583959a672084d/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__71.
                                 for (mem = 0; mem <= 31; mem++) begin : L1_FETCH_Instr_Mem //_/mem
                                    
                                 end
                                 for (bank = 0; bank <= 3; bank++) begin : L1c_FETCH_Instr_Bank //_/bank 
                                    
                                    for (mem = 0; mem <= 31; mem++) begin : L2b_Mem //_/mem
                                       
                                    end
                                 end
                              //_\end_source
                           //_\end_source
                        //_\end_source
               
               
               
            //_\end_source
            
         //_\end_source
      //_\end_source
   //_\end_source
   //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 6349   // Instantiated from tt_um_warpv.tlv, 62 as: m5+warpv_makerchip_tb()
      
      
      //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 4200   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 6352 as: m5+call(m5_get(tb_macro_name))
         //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 1227   // Instantiated from /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv, 4201 as: m5+default_makerchip_tb()
            //_|fetch
               //_/instr
                  //_@0
                     assign FETCH_Instr_passed_a0 = ! FETCH_Instr_reset_a0 && (FETCH_Instr_Pc_a0 == 52) && FETCH_Instr_good_path_a0;
                     assign FETCH_Instr_failed_a0 = cyc_cnt > 200  || ((FETCH_Instr_Pc_a0 == 48) && FETCH_Instr_good_path_a0);
         //_\end_source
      //_\end_source
   //_\end_source
   //_\source /raw.githubusercontent.com/stevehoover/warpv/2bd28077b7526d460f4615e687ab71e074a35f5a/warpv.tlv 6334   // Instantiated from tt_um_warpv.tlv, 63 as: m5+makerchip_pass_fail()
      //_|done
         //_@0
            // Assert these to end simulation (before Makerchip cycle limit).
            assign passed = & FETCH_Instr_passed_a0;
            assign failed = | FETCH_Instr_failed_a0;
   //_\end_source

   // Connect IOs.
   assign uo_out = {6'b0, failed, passed};
   assign uio_out = 8'b0;
   assign uio_oe = 8'b0;

//_\SV
endmodule


// Undefine macros defined by SandPiper.
`undef BOGUS_USE
